<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://kubevirt.io//feed/news.xml" rel="self" type="application/atom+xml" /><link href="https://kubevirt.io//" rel="alternate" type="text/html" /><updated>2022-06-16T20:51:06+00:00</updated><id>https://kubevirt.io//feed/news.xml</id><title type="html">KubeVirt.io | News</title><subtitle>Virtual Machine Management on Kubernetes</subtitle><entry><title type="html">Load-balancer for virtual machines on bare metal Kubernetes clusters</title><link href="https://kubevirt.io//2022/Virtual-Machines-with-MetalLB.html" rel="alternate" type="text/html" title="Load-balancer for virtual machines on bare metal Kubernetes clusters" /><published>2022-04-03T00:00:00+00:00</published><updated>2022-04-03T00:00:00+00:00</updated><id>https://kubevirt.io//2022/Virtual-Machines-with-MetalLB</id><content type="html" xml:base="https://kubevirt.io//2022/Virtual-Machines-with-MetalLB.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Over the last year, Kubevirt and MetalLB have shown to be powerful duo in order to support fault-tolerant access to an application on virtual machines through an external IP address. 
As a Cluster administrator using an on-prem cluster without a network load-balancer, now it’s possible to use MetalLB operator to provide load-balancer capabilities (with Services of type <code class="language-plaintext highlighter-rouge">LoadBalancer</code>) to virtual machines.</p>

<h2 id="metallb">MetalLB</h2>

<p><a href="https://metallb.universe.tf/">MetalLB</a> allows you to create Kubernetes services of type <code class="language-plaintext highlighter-rouge">LoadBalancer</code>, and provides network load-balancer implementation in on-prem clusters that don’t run on a cloud provider.
MetalLB is responsible for assigning/unassigning an external IP Address to your service, using IPs from pre-configured pools. In order for the external IPs to be announced externally, MetalLB works in 2 modes, Layer 2 and BGP:</p>

<ul>
  <li>
    <p>Layer 2 mode (ARP/NDP):</p>

    <p>This mode - which actually does not implement real load-balancing behavior - provides a failover mechanism where a single node owns the <code class="language-plaintext highlighter-rouge">LoadBalancer</code> service, until it fails, triggering another node to be chosen as the service owner. This configuration mode makes the IPs reachable from the local network.<br />
In this method, the MetalLB speaker pod announces the IPs in ARP (for IPv4) and NDP (for IPv6) protocols over the host network. From a network perspective, the node owning the service appears to have multiple IP addresses assigned to a network interface. After traffic is routed to the node, the service proxy sends the traffic to the application pods.</p>
  </li>
  <li>
    <p>BGP mode:</p>

    <p>This mode provides real load-balancing behavior, by establishing BGP peering sessions with the network routers - which advertise the external IPs of the <code class="language-plaintext highlighter-rouge">LoadBalancer</code> service, distributing the load over the nodes.</p>
  </li>
</ul>

<p>To read more on MetalLB concepts, implementation and limitations, please read <a href="https://metallb.universe.tf/concepts/">its documentation</a>.</p>

<h2 id="demo-virtual-machine-with-external-ip-and-metallb-load-balancer">Demo: Virtual machine with external IP and MetalLB load-balancer</h2>

<p>With the following recipe we will end up with a nginx server running on a virtual machine, accessible outside the cluster using MetalLB load-balancer with Layer 2 mode.</p>

<h3 id="demo-environment-setup">Demo environment setup</h3>

<p>We are going to use <a href="https://kind.sigs.k8s.io">kind</a> provider as an ephemeral Kubernetes cluster.</p>

<p>Prerequirements:</p>
<ul>
  <li>First install kind on your machine following its <a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation">installation guide</a>.</li>
  <li>To use kind, you will also need to <a href="https://docs.docker.com/install/">install docker</a>.</li>
</ul>

<h4 id="external-ips-on-macos-and-windows">External IPs on macOS and Windows</h4>

<p>This demo runs Docker on Linux, which allows sending traffic directly to the load-balancer’s external IP if the IP space is within the docker IP space.
On macOS and Windows however, docker does not expose the docker network to the host, rendering the external IP unreachable from other kind nodes. In order to workaround this, one could expose pods and services using extra port mappings as shown in the extra port mappings section of kind’s <a href="https://kind.sigs.k8s.io/docs/user/configuration#extra-port-mappings">Configuration Guide</a>.</p>

<h3 id="deploying-cluster">Deploying cluster</h3>

<p>To start a kind cluster:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kind create cluster
</code></pre></div></div>

<p>In order to interact with the specific cluster created:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl cluster-info <span class="nt">--context</span> kind-kind
</code></pre></div></div>

<h3 id="installing-components">Installing components</h3>

<h4 id="installing-metallb-on-the-cluster">Installing MetalLB on the cluster</h4>

<p>There are <a href="https://metallb.universe.tf/installation/">many ways</a> to install MetalLB. For the sake of this example, we will install MetalLB via manifests. To do this, follow this <a href="https://metallb.universe.tf/installation/#installation-by-manifest">guide</a>. 
Confirm successful installation by waiting for MetalLB pods to have a status of Running:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">-n</span> metallb-system <span class="nt">--watch</span>
</code></pre></div></div>

<h4 id="installing-kubevirt-on-the-cluster">Installing Kubevirt on the cluster</h4>

<p>Following Kubevirt <a href="https://kubevirt.io/user-guide/operations/installation/#installing-kubevirt-on-kubernetes">user guide</a> to install released version v0.51.0</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">RELEASE</span><span class="o">=</span>v0.51.0
kubectl apply <span class="nt">-f</span> <span class="s2">"https://github.com/kubevirt/kubevirt/releases/download/</span><span class="k">${</span><span class="nv">RELEASE</span><span class="k">}</span><span class="s2">/kubevirt-operator.yaml"</span>
kubectl apply <span class="nt">-f</span> <span class="s2">"https://github.com/kubevirt/kubevirt/releases/download/</span><span class="k">${</span><span class="nv">RELEASE</span><span class="k">}</span><span class="s2">/kubevirt-cr.yaml"</span>
kubectl <span class="nt">-n</span> kubevirt <span class="nb">wait </span>kv kubevirt <span class="nt">--timeout</span><span class="o">=</span>360s <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available
</code></pre></div></div>

<p>Now we have a Kubernetes cluster with all the pieces to start the Demo.</p>

<h3 id="network-resources-configuration">Network resources configuration</h3>

<h4 id="setting-address-pool-to-be-used-by-the-loadbalancer">Setting Address Pool to be used by the LoadBalancer</h4>

<p>In order to complete the Layer 2 mode configuration, we need to set a range of IP addresses for the LoadBalancer to use.
On Linux we can use the docker kind network (macOS and Windows users see <a href="#external-ips-on-macos-and-windows">External IPs Prerequirement</a>), so by using this command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network inspect <span class="nt">-f</span> <span class="s1">''</span> kind
</code></pre></div></div>

<p>You should get the subclass you can set the IP range from. The output should contain a cidr such as 172.18.0.0/16.
Using this result we will create the following Layer 2 address pool with 172.18.1.1-172.18.1.16 range:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF | kubectl apply -f -</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">metallb-system</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">config</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">address-pools:</span>
    <span class="s">- name: addresspool-sample1</span>
      <span class="s">protocol: layer2</span>
      <span class="s">addresses:</span>
      <span class="s">- 172.18.1.1-172.18.1.16</span>
<span class="s">EOF</span>
</code></pre></div></div>

<h3 id="network-utilization">Network utilization</h3>

<h4 id="spin-up-a-virtual-machine-running-nginx">Spin up a Virtual Machine running Nginx</h4>

<p>Now it’s time to start-up a virtual machine running nginx using the following yaml.
The virtual machine has a <code class="language-plaintext highlighter-rouge">metallb-service=nginx</code> we created to use when creating the service.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF | kubectl apply -f -</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubevirt.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualMachine</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fedora-nginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">metallb-service</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">running</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">metallb-service</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">domain</span><span class="pi">:</span>
        <span class="na">devices</span><span class="pi">:</span>
          <span class="na">disks</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">disk</span><span class="pi">:</span>
                <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">containerdisk</span>
            <span class="pi">-</span> <span class="na">disk</span><span class="pi">:</span>
                <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">cloudinitdisk</span>
          <span class="na">interfaces</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">masquerade</span><span class="pi">:</span> <span class="pi">{}</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">1024M</span>
      <span class="na">networks</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
          <span class="na">pod</span><span class="pi">:</span> <span class="pi">{}</span>
      <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerDisk</span><span class="pi">:</span>
            <span class="na">image</span><span class="pi">:</span> <span class="s">kubevirt/fedora-cloud-container-disk-demo</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">containerdisk</span>
        <span class="pi">-</span> <span class="na">cloudInitNoCloud</span><span class="pi">:</span>
            <span class="na">userData</span><span class="pi">:</span> <span class="pi">|-</span>
              <span class="s">#cloud-config</span>
              <span class="s">password: fedora</span>
              <span class="s">chpasswd: { expire: False }</span>
              <span class="s">packages:</span>
                <span class="s">- nginx</span>
              <span class="s">runcmd:</span>
                <span class="s">- [ "systemctl", "enable", "--now", "nginx" ]</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">cloudinitdisk</span>
<span class="s">EOF</span>
</code></pre></div></div>

<h4 id="expose-the-virtual-machine-with-a-typed-loadbalancer-service">Expose the virtual machine with a typed <code class="language-plaintext highlighter-rouge">LoadBalancer</code> service</h4>

<p>When creating the <code class="language-plaintext highlighter-rouge">LoadBalancer</code> typed service, we need to remember annotating the address-pool we want to use 
<code class="language-plaintext highlighter-rouge">addresspool-sample1</code> and also add the selector <code class="language-plaintext highlighter-rouge">metallb-service: nginx</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">cat &lt;&lt;EOF | kubectl apply -f -</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">metallb-nginx-svc</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">metallb.universe.tf/address-pool</span><span class="pi">:</span> <span class="s">addresspool-sample1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">externalTrafficPolicy</span><span class="pi">:</span> <span class="s">Local</span>
  <span class="na">ipFamilies</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">IPv4</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tcp-5678</span>
      <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">5678</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">80</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">LoadBalancer</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">metallb-service</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="s">EOF</span>
</code></pre></div></div>

<p>Notice that the service got assigned with an external IP from the range assigned by the address pool:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get service <span class="nt">-n</span> default metallb-nginx-svc
</code></pre></div></div>

<p>Example output:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME                TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>          AGE
metallb-nginx-svc   LoadBalancer   10.96.254.136   172.18.1.1    5678:32438/TCP   53s
</code></pre></div></div>

<h4 id="access-the-virtual-machine-from-outside-the-cluster">Access the virtual machine from outside the cluster</h4>

<p>Finally, we can check that the nginx server is accessible from outside the cluster:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-s</span> <span class="nt">-o</span> /dev/null 172.18.1.1:5678 <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"URL exists"</span>
</code></pre></div></div>

<p>Example output:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>URL exists
</code></pre></div></div>
<p>Note that it may take a short while for the URL to work after setting the service.</p>

<h2 id="doing-this-on-your-own-cluster">Doing this on your own cluster</h2>

<p>Moving outside the demo example, one who would like use MetalLB on their real life cluster, should also take other considerations in mind:</p>
<ul>
  <li>User privileges: you should have <code class="language-plaintext highlighter-rouge">cluster-admin</code> privileges on the cluster - in order to install MetalLB.</li>
  <li>IP Ranges for MetalLB: getting IP Address pools allocation for MetalLB depends on your cluster environment:
    <ul>
      <li>If you’re running a bare-metal cluster in a shared host environment, you need to first reserve this IP Address pool from your hosting provider.</li>
      <li>Alternatively, if you’re running on a private cluster, you can use one of the private IP Address spaces (a.k.a RFC1918 addresses). Such addresses are free, and work fine as long as you’re only providing cluster services to your LAN.</li>
    </ul>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>In this blog post we used MetalLB to expose a service using an external IP assigned to a virtual machine. 
This illustrates how virtual machine traffic can be load-balanced via a service.</p>]]></content><author><name>Ram Lavi</name></author><category term="news" /><category term="Kubevirt" /><category term="kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="load-balancer" /><category term="MetalLB" /><summary type="html"><![CDATA[This post illustrates setting up a virtual machine with MetalLB LoadBalancer service.]]></summary></entry><entry><title type="html">Dedicated migration network in KubeVirt</title><link href="https://kubevirt.io//2022/Dedicated-migration-network.html" rel="alternate" type="text/html" title="Dedicated migration network in KubeVirt" /><published>2022-01-25T00:00:00+00:00</published><updated>2022-01-25T00:00:00+00:00</updated><id>https://kubevirt.io//2022/Dedicated-migration-network</id><content type="html" xml:base="https://kubevirt.io//2022/Dedicated-migration-network.html"><![CDATA[<p>Since version 0.49, KubeVirt supports live migrating VMIs over a separate network than the one Kubernetes is running on.</p>

<p>Running migrations over a dedicated network is a great way to increase migration bandwidth and reliability.</p>

<p>This article gives an overview of the feature as well as a concrete example. For more technical information, refer to the <a href="https://kubevirt.io/user-guide/operations/live_migration/#using-a-different-network-for-migrations">KubeVirt documentation</a>.</p>

<h2 id="hardware-configuration">Hardware configuration</h2>

<p>The simplest way to use the feature is to find an unused NIC on every worker node, and to connect them all to the same switch.</p>

<p>All NICs must have the same name. If they don’t, they should be permanently renamed.
The process for renaming NICs varies depending on your operating system, refer to its documentation if you need help.</p>

<p>Adding servers to the network for services like DHCP or DNS is an option but it is not required.
If a DHCP is running, it is best if it doesn’t provide routes to other networks / the internet, to keep the migration network isolated.</p>

<h2 id="cluster-configuration">Cluster configuration</h2>

<p>The interface between the physical network and KubeVirt is a NetworkAttachmentDefinition (NAD), created in the namespace where KubeVirt is installed.</p>

<p>The implementation of the NAD is up to the admin, as long as it provides a link to the secondary network.
The admin must also ensure that the NAD is able to provide cluster-wide IPs, either through a physical DHCP, or with another CNI plugin like <a href="https://github.com/k8snetworkplumbingwg/whereabouts">whereabouts</a></p>

<p>Important: the subnet used here must be completely distinct from the ones used by the main Kubernetes network, to ensure proper routing.</p>

<h2 id="testing">Testing</h2>

<p>If you just want to test the feature, KubeVirtCI supports the creation of multiple nodes, as well as secondary networks.
All you need is to define the right environment variables before starting the cluster.</p>

<p>See the example below for more info (note that text in the “video” can actually be selected and copy/pasted).</p>

<h2 id="example">Example</h2>

<p>Here is a quick <a href="https://asciinema.org/a/464272">example</a> of a dual-node KubeVirtCI cluster running a migration over a secondary network.</p>

<p>The description of the clip includes more detailed information about the steps involved.</p>]]></content><author><name>Jed Lejosne</name></author><category term="news" /><category term="kubevirt" /><category term="kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="live migration" /><category term="dedicated network" /><summary type="html"><![CDATA[KubeVirt now supports using a separate network for live migrations]]></summary></entry><entry><title type="html">KubeVirt Summit is coming back!</title><link href="https://kubevirt.io//2022/KubeVirt-Summit-2022.html" rel="alternate" type="text/html" title="KubeVirt Summit is coming back!" /><published>2022-01-24T00:00:00+00:00</published><updated>2022-01-24T00:00:00+00:00</updated><id>https://kubevirt.io//2022/KubeVirt-Summit-2022</id><content type="html" xml:base="https://kubevirt.io//2022/KubeVirt-Summit-2022.html"><![CDATA[<p>The second online <a href="/summit/">KubeVirt Summit</a> is coming on February 16, 2022!</p>

<h2 id="when">When</h2>

<p>The event will take place online during two half-days:</p>

<ul>
  <li>Dates: February 16 and 17, 2022.</li>
  <li>Time: 14:00 – 19:00 UTC (9:00–14:00 EST, 15:00–20:00 CET)</li>
</ul>

<h2 id="register">Register</h2>

<p><a href="/summit/">KubeVirt Summit</a> is hosted on Community.CNCF.io. Because of how that platform works, you need to register for each of the two days of the summit independantly:</p>

<ul>
  <li><a href="https://community.cncf.io/events/details/cncf-kubevirt-community-presents-kubevirt-summit-2022-day-1/">Register for Day 1</a></li>
  <li><a href="https://community.cncf.io/events/details/cncf-kubevirt-community-presents-kubevirt-summit-2022-day-2/">Register for Day 2</a></li>
</ul>

<p>You will need to create an account with CNCF.io if you have not before. Attendance is free.</p>

<h2 id="keep-up-to-date">Keep up to date</h2>

<p>Connect with the KubeVirt Community through our <a href="/community">community page</a>.</p>

<p>We are looking forward to meeting you there!</p>]]></content><author><name>Chandler Wilkerson</name></author><category term="news" /><category term="kubevirt" /><category term="event" /><category term="community" /><summary type="html"><![CDATA[Join us for the KubeVirt community's second annual dedicated online event]]></summary></entry><entry><title type="html">Running real-time workloads with improved performance</title><link href="https://kubevirt.io//2021/Running-Realtime-Workloads.html" rel="alternate" type="text/html" title="Running real-time workloads with improved performance" /><published>2021-10-13T00:00:00+00:00</published><updated>2021-10-13T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Running-Realtime-Workloads</id><content type="html" xml:base="https://kubevirt.io//2021/Running-Realtime-Workloads.html"><![CDATA[<h2 id="motivation">Motivation</h2>

<p>It has been possible in KubeVirt for some time already to run a VM running with a RT kernel, however the performance of such workloads never achieved parity against running on top of a bare metal host virtualized. With the availability of NUMA and CPUManager as features in KubeVirt, we were close to a point where we had almost all the ingredients to deliver the <a href="https://www.libvirt.org/kbase/kvm-realtime.html">recommended</a> tunings in libvirt for achieving the low CPU latency needed for such workloads. We were missing two important settings:</p>
<ul>
  <li>The ability to configure the VCPUs to run with real-time scheduling policy.</li>
  <li>Lock the VMs huge pages in RAM to prevent swapping.</li>
</ul>

<h2 id="setting-up-the-environment">Setting up the Environment</h2>
<p>To achieve the lowest latency possible in a given environment, first it needs to be configured to allow its resources to be consumed efficiently.</p>

<h3 id="the-cluster">The Cluster</h3>
<p>The target node has to be configured to reserve memory for hugepages and the kernel to allow threads to run with real-time scheduling policy. The memory can be reserved as a <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html">kernel boot parameter</a> or by changing the kernel’s page count at <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html">runtime</a>.</p>

<p>The kernel’s runtime scheduling limit can be adjusted either by installing a real-time kernel in the node (the recommended option), or changing the kernel’s setting <code class="language-plaintext highlighter-rouge">kernel.sched_rt_runtime_us</code> to equal -1, to allow for unlimited runtime of real-time scheduled threads. This kernel setting defines the time period to be devoted to running real-time threads. KubeVirt will detect if the node has been configured with unlimited runtime and will label the node with <code class="language-plaintext highlighter-rouge">kubevirt.io/realtime</code> to highlight the capacity of running real-time workloads. Later on we’ll come back to this label when we talk about how the workload is scheduled.</p>

<p>It is also recommended tuning the node’s BIOS settings for optimal real-time performance is also recommended to achieve even lower CPU latencies. Consult with your hardware provider to obtain the information on how to best tune your equipment.</p>

<h3 id="kubevirt">KubeVirt</h3>
<p>The VM will require to be granted fully dedicated CPUs and be able to use huge pages. These requirements can be achieved in KubeVirt by enabling the feature gates of CPUManager and NUMA in the KubeVirt CR. There is no dedicated feature gate to enable the new real-time optimizations.</p>

<h2 id="the-manifest">The Manifest</h2>
<p>With the cluster configured to provide the dedicated resources for the workload, it’s time to review an example of a VM manifest using the optimizations for low CPU latency. The first focus is to reduce the VM’s I/O by limiting it’s devices to only serial console:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.devices.autoattachSerialConsole</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">spec.domain.devices.autoattachMemBalloon</span><span class="pi">:</span> <span class="no">false</span>
<span class="na">spec.domain.devices.autoattachGraphicsDevice</span><span class="pi">:</span> <span class="no">false</span>
</code></pre></div></div>

<p>The pod needs to have a guaranteed QoS for its memory and CPU resources, to make sure that the CPU manager will dedicate the requested CPUs to the pod.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.resources.request.cpu</span><span class="pi">:</span> <span class="m">2</span>
<span class="na">spec.domain.resources.request.memory</span><span class="pi">:</span> <span class="s">1Gi</span>
<span class="na">spec.domain.resources.limits.cpu</span><span class="pi">:</span> <span class="m">2</span>
<span class="na">spec.domain.resources.limits.memory</span><span class="pi">:</span> <span class="s">1Gi</span>
</code></pre></div></div>

<p>Still on the CPU front, we add the settings to instruct the KVM to give a clear visibility of the host’s features to the guest, request the CPU manager in the node to isolate the assigned CPUs and to make sure that the emulator and IO threads in the VM run in their own dedicated VCPU rather than sharing the computational time with the workload.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.model</span><span class="pi">:</span> <span class="s">host-passthrough</span>
<span class="na">spec.domain.cpu.dedicateCpuPlacement</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">spec.domain.cpu.isolateEmulatorThread</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">spec.domain.cpu.ioThreadsPolicy</span><span class="pi">:</span> <span class="s">auto</span>
</code></pre></div></div>

<p>We also request the huge pages size and guaranteed NUMA topology that will pin the CPU and memory resources to a single NUMA node in the host. The Kubernetes scheduler will perform due diligence to schedule the pod in a node with enough free huge pages of the given size.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.numa.guestMappingPassthrough</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">spec.domain.memory.hugepages.pageSize</span><span class="pi">:</span> <span class="s">1Gi</span>
</code></pre></div></div>

<p>Lastly, we define the new real-time settings to instruct KubeVirt to apply the real-time scheduling policy for the pinned VCPUs and lock the process memory to avoid from being swapped by the host. In this example, we’ll configure the workload to only apply the real-time scheduling policy to VCPU 0.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.realtime.mask</span><span class="pi">:</span> <span class="m">0</span>
</code></pre></div></div>

<p>Alternatively, if no <code class="language-plaintext highlighter-rouge">mask</code> value is specified, all requested CPUs will be configured for real-time scheduling.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.realtime</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p>The following yaml is a complete manifest including all the settings we just reviewed.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubevirt.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualMachine</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">kubevirt.io/vm</span><span class="pi">:</span> <span class="s">fedora-realtime</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fedora-realtime</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">running</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">kubevirt.io/vm</span><span class="pi">:</span> <span class="s">fedora-realtime</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">domain</span><span class="pi">:</span>
        <span class="na">devices</span><span class="pi">:</span>
          <span class="na">autoattachSerialConsole</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">autoattachMemBalloon</span><span class="pi">:</span> <span class="no">false</span>
          <span class="na">autoattachGraphicsDevice</span><span class="pi">:</span> <span class="no">false</span>
          <span class="na">disks</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">disk</span><span class="pi">:</span>
              <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">containerdisk</span>      
          <span class="pi">-</span> <span class="na">disk</span><span class="pi">:</span>
              <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">cloudinitdisk</span>
        <span class="na">machine</span><span class="pi">:</span>
          <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">1Gi</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="m">2</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">1Gi</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="m">2</span>
        <span class="na">cpu</span><span class="pi">:</span>
          <span class="na">model</span><span class="pi">:</span> <span class="s">host-passthrough</span>
          <span class="na">dedicatedCpuPlacement</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">isolateEmulatorThread</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">ioThreadsPolicy</span><span class="pi">:</span> <span class="s">auto</span>
          <span class="na">features</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tsc-deadline</span>
              <span class="na">policy</span><span class="pi">:</span> <span class="s">require</span>
          <span class="na">numa</span><span class="pi">:</span>
            <span class="na">guestMappingPassthrough</span><span class="pi">:</span> <span class="pi">{}</span>
          <span class="na">realtime</span><span class="pi">:</span>
            <span class="na">mask</span><span class="pi">:</span> <span class="s2">"</span><span class="s">0"</span>
        <span class="na">memory</span><span class="pi">:</span>
          <span class="na">hugepages</span><span class="pi">:</span>
            <span class="na">pageSize</span><span class="pi">:</span> <span class="s">1Gi</span>
      <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
      <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">containerDisk</span><span class="pi">:</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/kubevirt/fedora-realtime-container-disk:20211008_5a22acb18</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">containerdisk</span>
      <span class="pi">-</span> <span class="na">cloudInitNoCloud</span><span class="pi">:</span>
          <span class="na">userData</span><span class="pi">:</span> <span class="pi">|-</span>
            <span class="s">#cloud-config</span>
            <span class="s">password: fedora</span>
            <span class="s">chpasswd: { expire: False }</span>
            <span class="s">bootcmd:</span>
              <span class="s">- tuned-adm profile realtime</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">cloudinitdisk</span>
</code></pre></div></div>

<h2 id="the-deployment">The Deployment</h2>
<p>Because the manifest has enabled the real-time setting, when deployed KubeVirt applies the node label selector so that the Kubernetes scheduler will place the deployment in a node that is able to run threads with real-time scheduling policy (node label <code class="language-plaintext highlighter-rouge">kubevirt.io/realtime</code>). But there’s more, because the manifest also specifies the pod’s resource need of dedicated CPUs, KubeVirt will also add the node selector of <code class="language-plaintext highlighter-rouge">cpumanager=true</code> to guarantee that the pod is able to use the assigned CPUs alone. And finally, the scheduler also takes care of guaranteeing that the target node has sufficient free huge pages of the specified size (1Gi in our example) to satisfy the memory requested. With all these validations checked, the pod is successfully scheduled.</p>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>Being able to run real-time workloads in KubeVirt with lower CPU latency opens new possibilities and expands the use cases where KubeVirt can assist in migrating legacy VMs into the cloud. Real-time workloads are extremely sensitive to the amount of layers between the bare metal and its runtime: the more layers in between, the higher the latency will be. The changes introduced in KubeVirt help reduce such waste and provide lower CPU latencies as the hardware is more efficiently tuned.</p>]]></content><author><name>Jordi Gil</name></author><category term="news" /><category term="kubevirt" /><category term="kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="real-time" /><category term="NUMA" /><category term="CPUManager" /><summary type="html"><![CDATA[This blog post details the various enhancements made to improve the performance of real-time workloads in KubeVirt]]></summary></entry><entry><title type="html">Import AWS AMIs as KubeVirt Golden Images</title><link href="https://kubevirt.io//2021/Importing-EC2-to-KubeVirt.html" rel="alternate" type="text/html" title="Import AWS AMIs as KubeVirt Golden Images" /><published>2021-09-21T00:00:00+00:00</published><updated>2021-09-21T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Importing-EC2-to-KubeVirt</id><content type="html" xml:base="https://kubevirt.io//2021/Importing-EC2-to-KubeVirt.html"><![CDATA[<h2 id="breaking-out">Breaking Out</h2>

<p>There comes a point where an operations team has invested so heavily in a Iaas platform that they are effectively locked into that platform. For example, here’s one scenario outlining how this can happen. An operations team has created automation around building VM images and keeping images up-to-date. In AWS that automation likely involves starting an EC2 instance, injecting some application logic into that instance, sealing the instance’s boot source as an AMI, and finally copying that AMI around to all the AWS regions the team deploys in.</p>

<p>If the team was interested in evaluating KubeVirt as an alternative Iaas platform to AWS’s EC2, given the team’s existing tooling there’s not a clear path for doing this. It’s that scenario where the tooling in the <a href="https://github.com/davidvossel/kubevirt-cloud-import">kubevirt-cloud-import</a> project comes into play.</p>

<h2 id="kubevirt-cloud-import">Kubevirt Cloud Import</h2>

<p>The <a href="https://github.com/davidvossel/kubevirt-cloud-import">KubeVirt Cloud Import</a> project explores the practicality of transitioning VMs from various cloud providers into KubeVirt. As of writing this, automation for exporting AMIs from EC2 into KubeVirt works, and it’s really not all that complicated.</p>

<p>This blog post will explore the fundamentals of how AMIs are exported, and how the KubeVirt Cloud Import project leverages these techniques to build automation pipelines.</p>

<h2 id="nuts-and-bolts-of-importing-amis">Nuts and Bolts of Importing AMIs</h2>

<h3 id="official-aws-ami-export-support">Official AWS AMI Export Support</h3>

<p>AWS supports an <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport_image.html">api</a> for exporting AMIs as a file to an s3 bucket. This support works quite well, however there’s a long list of <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport_image.html#limits-image-export">limitations</a> that impact what AMIs are eligible for export. The most limiting of those items is the one that prevents any image built from an AMI on the marketplace from being eligible for the official export support.</p>

<h3 id="unofficial-aws-export-support">Unofficial AWS export Support</h3>

<p>Regardless of what AWS officially supports or not, there’s absolutely nothing preventing someone from exporting an AMI’s contents themselves. The technique just involves creating an EC2 instance, attaching an EBS volume (containing the AMI contents) as a block device, then streaming that block devices contents where ever you want.</p>

<p>Theoretically, the steps roughly look like this.</p>

<ul>
  <li>Convert AMI to a volume by finding the underlying AMI’s snapshot and converting it to an EBS volume.</li>
  <li>Create an EC2 instance with the EBS volume containing the AMI contents as a secondary data device.</li>
  <li>Within the EC2 guest, copy the EBS device’s contents as a disk img <code class="language-plaintext highlighter-rouge">dd if=/dev/xvda of=/tmp/disk/disk.img</code></li>
  <li>Then upload the disk image to an object store like s3. <code class="language-plaintext highlighter-rouge">aws s3 cp /tmp/disk/disk.img s3://my-b1-bucket/ upload: ../tmp/disk/disk.img to s3://my-b1-bucket/disk.img</code></li>
</ul>

<h3 id="basics-of-importing-data-into-kubevirt">Basics of Importing Data into KubeVirt</h3>

<p>Once a disk image is in s3, a KubeVirt companion project called the <a href="https://github.com/kubevirt/containerized-data-importer">Containerized Data Importer</a> (or CDI for short) can be used to import the disk from s3 into a PVC within the KubeVirt cluster. This import flow can be expressed as a CDI DataVolume custom resource.</p>

<p>Below is an example yaml for importing s3 contents into a PVC using a DataVolume</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">cdi.kubevirt.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DataVolume</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">example-import-dv"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">source</span><span class="pi">:</span>
      <span class="na">s3</span><span class="pi">:</span>
         <span class="na">url</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://s3.us-west-2.amazonaws.com/my-ami-exports/kubevirt-image-exports/export-ami-0dc4e69702f74df50.vmdk"</span>
         <span class="na">secretRef</span><span class="pi">:</span> <span class="s2">"</span><span class="s">my-s3-credentials"</span>
  <span class="na">pvc</span><span class="pi">:</span>
    <span class="na">accessModes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">requests</span><span class="pi">:</span>
        <span class="na">storage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">6Gi"</span>
</code></pre></div></div>

<p>Once the AMI file content is stored in a PVC, CDI can be used further to clone that AMI’s PVC on a per VM basis. This effectively recreates the AMI to EC2 relationship that exists in AWS. You can find more information about CDI <a href="https://github.com/kubevirt/containerized-data-importer">here</a></p>

<h2 id="automating-ami-import">Automating AMI import</h2>

<p>Using the technique of exporting an AMI to an s3 bucket and importing the AMI from s3 into a KubeVirt cluster using CDI, the Kubevirt Cloud Import project provides the glue necessary for tying all of these pieces together in the form of the <code class="language-plaintext highlighter-rouge">import-ami</code> cli command and a Tekton task.</p>

<h2 id="automation-using-the-import-ami-cli-command">Automation using the import-ami CLI command</h2>

<p>The <code class="language-plaintext highlighter-rouge">import-ami</code> takes a set of arguments related to the AMI you wish to import into KubeVirt and the name of the PVC you’d like the AMI to be imported into. Upon execution, import-ami will call all the appropriate AWS and KubeVirt APIs to make this work. The result is a PVC with the AMI contents that is capable of being launched by a KubeVirt VM.</p>

<p>In the example below, A publicly shared <a href="https://alt.fedoraproject.org/cloud/">fedora34 AMI</a> is imported into the KubeVirt cluster as a PVC called fedora34-golden-image</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">export </span><span class="nv">S3_BUCKET</span><span class="o">=</span>my-bucket
<span class="nb">export </span><span class="nv">S3_SECRET</span><span class="o">=</span>s3-readonly-cred
<span class="nb">export </span><span class="nv">AWS_REGION</span><span class="o">=</span>us-west-2
<span class="nb">export </span><span class="nv">AMI_ID</span><span class="o">=</span>ami-00a4fdd3db8bb2851
<span class="nb">export </span><span class="nv">PVC_STORAGECLASS</span><span class="o">=</span>rook-ceph-block
<span class="nb">export </span><span class="nv">PVC_NAME</span><span class="o">=</span>fedora34-golden-image

import-ami <span class="nt">--s3-bucket</span> <span class="nv">$S3_BUCKET</span> <span class="nt">--region</span> <span class="nv">$AWS_REGION</span> <span class="nt">--ami-id</span> <span class="nv">$AMI_ID</span> <span class="nt">--pvc-storageclass</span> <span class="nv">$PVC_STORAGECLASS</span> <span class="nt">--s3-secret</span> <span class="nv">$S3_SECRET</span> <span class="nt">--pvc-name</span> <span class="nv">$PVC_NAME</span>

</code></pre></div></div>

<h2 id="automation-using-the-import-ami-tekton-task">Automation using the import-ami Tekton Task</h2>

<p>In addition to the <code class="language-plaintext highlighter-rouge">import-ami</code> cli command, the KubeVirt Cloud Import project also includes a <a href="https://github.com/davidvossel/kubevirt-cloud-import/blob/main/tasks/import-ami/manifests/import-ami.yaml">Tekton task</a> which wraps the cli command and allows integrating AMI import into a Tekton pipeline.</p>

<p>Using a Tekton pipeline, someone can combine the task of importing an AMI into KubeVirt with the task of starting a VM using that AMI. An example pipeline can be found <a href="https://raw.githubusercontent.com/davidvossel/kubevirt-cloud-import/main/examples/create-vm-from-ami-pipeline.yaml">here</a> which outlines how this is accomplished.</p>

<p>Below is a pipeline run that uses the example pipeline to import the publicly shared fedora34 AMI into a PVC, then starts a VM using that imported AMI.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> &gt; pipeline-run.yaml
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: my-vm-creation-pipeline
  namespace: default
spec:
  serviceAccountName: my-kubevirt-service-account
  pipelineRef:
    name: create-vm-pipeline 
  params:
    - name: vmName
      value: vm-fedora34
    - name: s3Bucket
      value: my-kubevirt-exports
    - name: s3ReadCredentialsSecret
      value: my-s3-read-only-credentials
    - name: awsRegion
      value: us-west-2
    - name: amiId 
      value: ami-00a4fdd3db8bb2851
    - name: pvcStorageClass 
      value: rook-ceph-block
    - name: pvcName
      value: fedora34
    - name: pvcNamespace
      value: default
    - name: pvcSize
      value: 6Gi
    - name: pvcAccessMode
      value: ReadWriteOnce
    - name: awsCredentialsSecret
      value: my-aws-credentials
</span><span class="no">EOF

</span>kubectl create <span class="nt">-f</span> pipeline-run.yaml
</code></pre></div></div>

<p>After posting the pipeline run, watch for the pipeline run to complete.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pipelinerun
selecting docker as container runtime
NAME                      SUCCEEDED   REASON      STARTTIME   COMPLETIONTIME
my-vm-creation-pipeline   True        Succeeded   11m         9m54s
</code></pre></div></div>

<p>Then observe that the resulting VM is online</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get vmi
selecting docker as container runtime
NAME          AGE   PHASE     IP               NODENAME   READY
vm-fedora34   11m   Running   10.244.196.175   node01     True
</code></pre></div></div>

<p>For more detailed and up-to-date information about how to automate AMI import using Tekton, view the KubeVirt Cloud Import <a href="https://github.com/davidvossel/kubevirt-cloud-import/blob/main/README.md">README.md</a></p>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>The portability of workloads across different environments is becoming increasingly important and operations teams need to be vigilant about avoiding vendor lock in. For containers, Kubernetes is an attractive option because it provides a consistent API layer that can run across multiple cloud platforms. KubeVirt can provide that same level of consistency for VMs. As a community we need to invest further into automation tools that allow people to make the transition to KubeVirt.</p>]]></content><author><name>David Vossel</name></author><category term="news" /><category term="kubevirt" /><category term="kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="AWS" /><category term="EC2" /><category term="AMI" /><summary type="html"><![CDATA[This blog post outlines the fundamentals for how to import VMs from AWS into KubeVirt]]></summary></entry><entry><title type="html">Running virtual machines in Istio service mesh</title><link href="https://kubevirt.io//2021/Virtual-machines-in-Istio-service-mesh.html" rel="alternate" type="text/html" title="Running virtual machines in Istio service mesh" /><published>2021-08-13T00:00:00+00:00</published><updated>2021-08-13T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Virtual-machines-in-Istio-service-mesh</id><content type="html" xml:base="https://kubevirt.io//2021/Virtual-machines-in-Istio-service-mesh.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This blog post demonstrates running virtual machines in <a href="https://istio.io/">Istio</a> service mesh.</p>

<p>Istio service mesh allows to monitor, visualize, and manage traffic between pods and external services by
injecting a proxy container - a sidecar - which forwards inbound and outbound traffic of a pod/virtual machine.
This allows the sidecar to collect metadata about the proxied traffic and also actively interfere with it. For more in-depth information about the Istio proxy mechanism, see <a href="https://medium.com/open-5g-hypercore/episode-iii-meshville-7f0bb7ca0e3b">this blog post</a> published by Dough Smith et al.</p>

<p>The main features of Istio are traffic shifting (migrating traffic from an old to new version of a service), dynamic request routing, fault injection or traffic mirroring for testing/debugging purposes, and more.
Visit <a href="https://istio.io/latest/docs/tasks/">Istio documentation</a> to learn about all its features.
Istio featureset may be further extended by installing addons. Kiali, for example, is a UI dashboard that provides traffic information
of all microservices in a mesh, capable of composing communication graph between all microservices.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
  <li>KubeVirt <code class="language-plaintext highlighter-rouge">v0.43.0</code></li>
  <li>CRI-O <code class="language-plaintext highlighter-rouge">v1.19.0</code></li>
</ul>

<h2 id="limitations">Limitations</h2>

<p>Istio is only supported with masquerade network binding and pod network over IPv4.</p>

<h2 id="demo">Demo</h2>

<p>This section covers deployment of a local cluster with Istio service mesh, KubeVirt installation and creation of an Istio-enabled virtual machine.
Finally, Kiali dashboard is used to examine both inbound and outbound traffic of the created virtual machine.</p>

<h3 id="run-kubernetes-cluster">Run Kubernetes cluster</h3>

<p>In this blog post, we are going to use <a href="https://github.com/kubevirt/kubevirtci">kubevirtci</a> as our Kubernetes ephemeral cluster provider.</p>

<p>Follow these steps to deploy a local cluster with pre-installed Istio service mesh:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/kubevirt/kubevirtci
<span class="nb">cd </span>kubevirtci
<span class="nb">export </span><span class="nv">KUBEVIRTCI_TAG</span><span class="o">=</span>2108222252-0007793
<span class="c"># Pin to version used in this blog post in case</span>
<span class="c"># k8s-1.21 provider version disappears in the future</span>
git checkout <span class="nv">$KUBEVIRTCI_TAG</span>
<span class="nb">export </span><span class="nv">KUBEVIRT_NUM_NODES</span><span class="o">=</span>2
<span class="nb">export </span><span class="nv">KUBEVIRT_PROVIDER</span><span class="o">=</span>k8s-1.21
<span class="nb">export </span><span class="nv">KUBEVIRT_DEPLOY_ISTIO</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">KUBEVIRT_WITH_CNAO</span><span class="o">=</span><span class="nb">true
</span>make cluster-up
<span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span><span class="si">$(</span>./cluster-up/kubeconfig.sh<span class="si">)</span>
</code></pre></div></div>

<p>For details about Istio configuration, see Istio kubevirtci <a href="https://github.com/kubevirt/kubevirtci/blob/2108081530-91f55e3/cluster-provision/k8s/1.21/istio.sh">install script</a>.</p>

<h3 id="install-kubevirt">Install Kubevirt</h3>

<p>Following KubeVirt <a href="https://kubevirt.io/user-guide/operations/installation/#installing-kubevirt-on-kubernetes">user guide</a> to install released version <code class="language-plaintext highlighter-rouge">v0.43.0</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">RELEASE</span><span class="o">=</span>v0.43.0
kubectl apply <span class="nt">-f</span> <span class="s2">"https://github.com/kubevirt/kubevirt/releases/download/</span><span class="k">${</span><span class="nv">RELEASE</span><span class="k">}</span><span class="s2">/kubevirt-operator.yaml"</span>
kubectl apply <span class="nt">-f</span> <span class="s2">"https://github.com/kubevirt/kubevirt/releases/download/</span><span class="k">${</span><span class="nv">RELEASE</span><span class="k">}</span><span class="s2">/kubevirt-cr.yaml"</span>
kubectl <span class="nt">-n</span> kubevirt <span class="nb">wait </span>kv kubevirt <span class="nt">--timeout</span><span class="o">=</span>180s <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available
</code></pre></div></div>

<h3 id="install-istio-addons">Install Istio addons</h3>

<p>While the ephemeral kubevirtci installs core Istio components, addons like Kiali dashboard are not installed by default.
Download Istio manifests and client binary by running the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">ISTIO_VERSION</span><span class="o">=</span>1.10.0
curl <span class="nt">-L</span> https://istio.io/downloadIstio | sh -
</code></pre></div></div>

<p>and export path to the istioctl binary by following the output of the above command.</p>

<p>Finally, deploy Kiali, Jaeger and Prometheus addons:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> istio-<span class="k">${</span><span class="nv">ISTIO_VERSION</span><span class="k">}</span>/samples/addons/kiali.yaml
kubectl create <span class="nt">-f</span> istio-<span class="k">${</span><span class="nv">ISTIO_VERSION</span><span class="k">}</span>/samples/addons/jaeger.yaml
kubectl create <span class="nt">-f</span> istio-<span class="k">${</span><span class="nv">ISTIO_VERSION</span><span class="k">}</span>/samples/addons/prometheus.yaml
</code></pre></div></div>

<p><strong>Note:</strong> If there are errors when installing the addons, try running the command again. There may be timing issues which will be resolved when the command is run again.</p>

<h3 id="prepare-target-namespace">Prepare target namespace</h3>

<p>Before creating virtual machines, the target namespace needs to be configured for the Istio sidecar to be injected and working properly.
This involves adding a label and creating a <code class="language-plaintext highlighter-rouge">NetworkAttachmentDefinition</code> in the target namespace.</p>

<h4 id="istio-sidecar-injection">Istio sidecar injection</h4>

<p>Istio supports <a href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/">two ways of injecting</a> a sidecar to a pod - automatic and manual. For simplicity, we will only consider automatic sidecar injection in this demo, which is enabled by adding <code class="language-plaintext highlighter-rouge">istio-injection=enabled</code> label to target namespace:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl label namespace default istio-injection<span class="o">=</span>enabled
</code></pre></div></div>

<h4 id="network-attachment-definiton">Network attachment definiton</h4>

<p>When Multus is installed in k8s cluster, a <code class="language-plaintext highlighter-rouge">NetworkAttachmentDefinition</code> called <code class="language-plaintext highlighter-rouge">istio-cni</code> <strong>must</strong> be created in <strong>each</strong> namespace where Istio sidecar containers are to be used:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f -
apiVersion: "k8s.cni.cncf.io/v1"
kind: NetworkAttachmentDefinition
metadata:
  name: istio-cni
</span><span class="no">EOF
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">NetworkAttachmentDefinition</code> spec is empty, as its only purpose is to trigger the <code class="language-plaintext highlighter-rouge">istio-cni</code> binary, which configures the in-pod traffic routing.</p>

<h3 id="topology">Topology</h3>

<p>To demonstrate monitoring and tracing capabilities, we will create two VMIs within Istio service mesh:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">istio-vmi</code> repeatedly requests external HTTP service kubevirt.io, and serves a simple HTTP server on port 8080,</li>
  <li><code class="language-plaintext highlighter-rouge">cirros-vmi</code> repeatedly request the HTTP service running on the <code class="language-plaintext highlighter-rouge">istio-vmi</code> VMI.</li>
</ul>

<p>With this setup, both inbound and outbound
traffic metrics can be observed in Kiali dashboard for <code class="language-plaintext highlighter-rouge">istio-vmi</code>.</p>

<h3 id="create-vmi-resources">Create VMI resources</h3>

<p>An Istio aware virtual machine <strong>must</strong> be annotated with <code class="language-plaintext highlighter-rouge">sidecar.istio.io/inject: "true"</code>, regardless of used Istio injection mechanism.
Without this annotation, traffic would not be properly routed through the istio proxy sidecar.
Additonally, Istio uses <code class="language-plaintext highlighter-rouge">app</code> label for adding contextual information to the collected telemetry.
Both, the annotation and label can be seen in the following virtual machine example:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f -
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
metadata:
  annotations:
    sidecar.istio.io/inject: "true"
  labels:
    app: istio-vmi
  name: istio-vmi
spec:
  domain:
    devices:
      interfaces:
        - name: default
          masquerade: {}
          ports:
            - port: 8080
      disks:
        - disk:
            bus: virtio
          name: containerdisk
        - disk:
            bus: virtio
          name: cloudinitdisk
    resources:
      requests:
        memory: 1024M
  networks:
    - name: default
      pod: {}
  readinessProbe:
    httpGet:
      port: 8080
    initialDelaySeconds: 120
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 3
  terminationGracePeriodSeconds: 0
  volumes:
    - name: containerdisk
      containerDisk:
        image: kubevirt/fedora-cloud-container-disk-demo:devel
    - cloudInitNoCloud:
        userData: |
          #cloud-config
          password: fedora
          chpasswd: { expire: False }
          runcmd:
          - dnf install -y screen nc
          - while true ; do sh -c "nc -lp 8080 -c  </span><span class="se">\"</span><span class="sh">echo -e 'HTTP/1.1 200 OK</span><span class="se">\n\n</span><span class="sh">Hello'</span><span class="se">\"</span><span class="sh"> " ; done &amp;
          - while true ; do curl kubevirt.io &gt;out 2&gt;/dev/null ; sleep 1 ; done &amp;
      name: cloudinitdisk
</span><span class="no">EOF
</span></code></pre></div></div>

<p>The cloud init section of the VMI runs two loops requesting <code class="language-plaintext highlighter-rouge">kubevirt.io</code> website every second to generate outbound traffic (from the VMI) and serving simple HTTP server on port <code class="language-plaintext highlighter-rouge">8080</code>, which will be used for monitoring of inbound traffic (to the VMI).</p>

<p>Let’s also create a service for the VMI that will be used to access the http server in <code class="language-plaintext highlighter-rouge">istio-vmi</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f-
apiVersion: v1
kind: Service
metadata:
  name: istio-vmi-svc
spec:
  selector:
    app: istio-vmi
  ports:
  - port: 8080
    protocol: TCP
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Finally, create the <code class="language-plaintext highlighter-rouge">cirros-vmi</code> VMI, for the purpose of generating inbound traffic to <code class="language-plaintext highlighter-rouge">istio-vmi</code> VMI:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f -
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
metadata:
  annotations:
    sidecar.istio.io/inject: "true"
  name: cirros-vmi
  labels:
    app: cirros-vmi
spec:
  domain:
    devices:
      interfaces:
        - name: default
          masquerade: {}
      disks:
        - disk:
            bus: virtio
          name: containerdisk
        - disk:
            bus: virtio
          name: cloudinitdisk
    resources:
      requests:
        memory: 128M
  networks:
    - name: default
      pod: {}
  terminationGracePeriodSeconds: 0
  volumes:
    - name: containerdisk
      containerDisk:
        image: kubevirt/cirros-container-disk-demo:devel
    - name: cloudinitdisk
      cloudInitNoCloud:
        userData: |
          #!/bin/sh
          while true ; do curl istio-vmi-svc.default.svc.cluster.local:8080 ; sleep 1 ; done
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Wait for the <code class="language-plaintext highlighter-rouge">istio-vmi</code> to be ready:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span><span class="nv">condition</span><span class="o">=</span>ready <span class="nt">--timeout</span><span class="o">=</span>180s pod <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>istio-vmi
</code></pre></div></div>

<p>After creating the VMIs, the corresponding virt-launcher pods should have 3 ready containers, as shown in the snippet below:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods
NAME                             READY   STATUS    RESTARTS   AGE
virt-launcher-istio-vmi-XYZ      3/3     Running   0          4m13s
virt-launcher-cirros-vmi-XYZ     3/3     Running   0          2m21s
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Istioctl proxy-status</code> should report that the sidecar proxies running inside the virt-launcher pods have synced with Istio control plane:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>istioctl proxy-status
NAME                                          CDS        LDS        EDS        RDS          ISTIOD                      VERSION
virt-launcher-cirros-vmi-9f765.default        SYNCED     SYNCED     SYNCED     SYNCED       istiod-7d96484d6b-5d79g     1.10.0
virt-launcher-istio-vmi-99t8t.default         SYNCED     SYNCED     SYNCED     SYNCED       istiod-7d96484d6b-nk4cd     1.10.0
</code></pre></div></div>

<p><strong>Note:</strong> Displaying only relevant VMI entities.</p>

<h3 id="monitor-traffic-in-kiali-dashboard">Monitor traffic in Kiali dashboard</h3>

<p>With both VMIs up and running, we can open the Kiali dashboard and observe the traffic metrics.
Run the following command, to access Kiali dashboard:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>istioctl dashboard kiali
</code></pre></div></div>

<h4 id="topology-graph">Topology graph</h4>

<p>Let’s start by navigating to the topology graph by clicking the Graph menu item.</p>

<p><br /></p>
<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/topology-graph.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/topology-graph.png" itemprop="thumbnail" width="100%" alt="Topology graph" />
    </a>
    <figcaption itemprop="Topology graph of deployed VMIs showing the traffic flows"></figcaption>
  </figure>
</div>

<p>In the topology graph, we can observe the following traffic flows:</p>

<ul>
  <li>requests from <code class="language-plaintext highlighter-rouge">cirros-vmi</code> to <code class="language-plaintext highlighter-rouge">istio-vmi</code> via <code class="language-plaintext highlighter-rouge">istio-vmi-svc</code> service,</li>
  <li>requests from <code class="language-plaintext highlighter-rouge">istio-vmi</code> to <code class="language-plaintext highlighter-rouge">PasstroughCluster</code>. The <code class="language-plaintext highlighter-rouge">PastroughCluster</code> marks  destinations external to our service mesh.</li>
</ul>

<h4 id="workloads">Workloads</h4>

<p>Navigate to <code class="language-plaintext highlighter-rouge">istio-vmi</code> workload overview by clicking the <code class="language-plaintext highlighter-rouge">Workloads</code> menu item and selecting <code class="language-plaintext highlighter-rouge">istio-vmi</code> from the list.</p>

<p>The overview page presents partial topology graph with traffic related to <code class="language-plaintext highlighter-rouge">istio-vmi</code>. In our case, this graph is the same as the graph of our entire mesh.</p>

<p>Navigate to Inbound Metrics tab to see metrics charts of inbound traffic.</p>

<p><br /></p>
<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/istio-blog-vmi-istio-inbound-traffic.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/istio-blog-vmi-istio-inbound-traffic.png" itemprop="thumbnail" width="100%" alt="Inbound traffic metrics" />
    </a>
    <figcaption itemprop="Inbound traffic metrics for `istio-vmi`"></figcaption>
  </figure>
</div>

<p>In Request volume chart we can see that number of requests stabilizes at around <code class="language-plaintext highlighter-rouge">1 ops</code>, which matches our loop sending one reqest per second. Request throughput chart reveals that the requests consume around <code class="language-plaintext highlighter-rouge">4 kbit/s</code> of bandwidth.
Remaining two charts provide information about Request duration and size.</p>

<p>The same metrics are collected for outbound traffic as well, which can be seen in Outbound Metrics tab.</p>

<h2 id="cluster-teardown">Cluster teardown</h2>

<p>Run the following command to deprovision the ephemeral cluster:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make cluster-down
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>KubeVirt introduced <a href="https://kubevirt.io/user-guide/virtual_machines/istio_service_mesh/">support for Istio</a>, allowing virtual machines to be part of a service mesh.</p>

<p>This blog post covered running KubeVirt virtual machine in Istio service mesh using an ephemeral kubevirtci cluster. Kiali dashboard was used to observe inbound and outbound traffic of a virtual machine.</p>]]></content><author><name>Radim Hrazdil</name></author><category term="news" /><category term="kubevirt" /><category term="istio" /><category term="virtual machine" /><category term="VM" /><category term="service mesh" /><category term="mesh" /><summary type="html"><![CDATA[This blog post demonstrates running virtual machines in Istio service mesh.]]></summary></entry><entry><title type="html">Kubernetes Authentication Options using KubeVirt Client Library</title><link href="https://kubevirt.io//2021/kubevirt-api-auth.html" rel="alternate" type="text/html" title="Kubernetes Authentication Options using KubeVirt Client Library" /><published>2021-07-16T00:00:00+00:00</published><updated>2021-07-16T00:00:00+00:00</updated><id>https://kubevirt.io//2021/kubevirt-api-auth</id><content type="html" xml:base="https://kubevirt.io//2021/kubevirt-api-auth.html"><![CDATA[<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#requirements">Requirements</a></li>
  <li><a href="#setup">Setup</a>
    <ul>
      <li><a href="#compiling-our-test-application">Compiling our test application</a></li>
    </ul>
  </li>
  <li><a href="#running-our-application-externally-leveraging-a-kubeconfig-file">Running our application externally leveraging a kubeconfig file</a>
    <ul>
      <li><a href="#using-the-default-kubeconfig">Using the default kubeconfig</a></li>
      <li><a href="#creating-a-kubeconfig-for-the-service-account">Creating a kubeconfig for the service account</a></li>
    </ul>
  </li>
  <li><a href="#running-in-a-kubernetes-cluster">Running in a Kubernetes Cluster</a></li>
  <li><a href="#extending-rbac-role-across-namespaces">Extending RBAC Role across Namespaces</a></li>
  <li><a href="#creating-custom-rbac-roles">Creating Custom RBAC Roles</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
  <li><a href="#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Most interaction with the KubeVirt service can be handled using the <em>virtctl</em> command, or raw yaml applied to your Kubernetes cluster. But what if you want to have more direct programmatic control over the instantiation and management of those virtual machines? The KubeVirt project supplies a Go client library for interacting with KubeVirt called <a href="https://github.com/kubevirt/client-go">client-go</a>. This library allows you to write your own applications that interact directly with the KubeVirt api quickly and easily.</p>

<p>In this post, we will use a simple application to demonstrate how the KubeVirt client library authenticates with your Kubernetes cluster both in and out of your cluster. This application is based on the example application in the “client-go” library with a few small modifications to it, to allow for running both locally and within in the cluster. This tutorial assumes you have some knowledge of Go, and is not meant to be a Go training doc.</p>

<h2 id="requirements">Requirements</h2>

<p>In order to compile and run the test application locally you will need to have the Go programming language installed on your machine. If you do not have the latest version of Go installed, follow the steps on the <a href="https://golang.org/dl/">Downloads</a> page of the Go  web site before proceeding with the rest of the steps in this blog. The steps listed here were tested with Go version 1.16.</p>

<p>You will need a Kubernetes cluster running with the KubeVirt operator installed. If you do not have a cluster available, the easiest way to do this is to follow the steps outlined in the <a href="https://kubevirt.io/quickstart_minikube/">Quick Start with Minikube</a> lab.</p>

<p>The example application we will be using to demonstrate the authentication methods lists out the VMI and VM instances in your cluster in the current namespace. If you do not have any running VMs in your cluster, be sure to create at least one new virtual machine instance in your cluster. For guidance in creating a quick test vm see the <a href="https://kubevirt.io/labs/kubernetes/lab1.html">Use KubeVirt</a> lab.</p>

<h2 id="setup">Setup</h2>

<h3 id="compiling-our-test-application">Compiling our test application</h3>

<p>Start by cloning the example application repo <a href="https://github.com/xphyr/kubevirt-apiauth">https://github.com/xphyr/kubevirt-apiauth</a> and compiling our test application:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/xphyr/kubevirt-apiauth.git
<span class="nb">cd </span>kubevirt-apiauth/listvms
go build
</code></pre></div></div>

<p>Once the program compiles, test to ensure that the application compiled correctly. If you have a working Kubernetes context, running this command may return some values. If you do not have a current context, you will get an error. This is OK, we will discuss authentication next.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./listvms
2021/06/23 16:51:28 cannot obtain KubeVirt vm list: Get <span class="s2">"http://localhost:8080/apis/kubevirt.io/v1alpha3/namespaces/default/virtualmachines"</span>: dial tcp 127.0.0.1:8080: connect: connection refused
</code></pre></div></div>

<p>As long as the program runs, you are all set to move onto the next step.</p>

<h2 id="running-our-application-externally-leveraging-a-kubeconfig-file">Running our application externally leveraging a kubeconfig file</h2>

<p>The default authentication file for Kubernetes is the <a href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a> file. We will not be going into details of this file, but you can click the link to goto the documentation on the kubeconfig file to learn more about it. All you need to know at this time is that when you use the <em>kubectl</em> command you are using a kubeconfig file for your authentication.</p>

<h3 id="using-the-default-kubeconfig">Using the default kubeconfig</h3>

<p>If you haven’t already done so, validate that you have a successful connection to your cluster with the “<em>kubectl</em>” command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get nodes
NAME       STATUS   ROLES                  AGE     VERSION
minikube   Ready    control-plane,master   5d21h   v1.20.7
</code></pre></div></div>

<p>We now have a valid kubeconfig. On *nix OS such as Linux and OSX, this file is stored in your home directory at <code class="language-plaintext highlighter-rouge">~/.kube/config</code>. You should now be able to run our test application and get some results (assuming you have some running vms in your cluster).</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./listvms/listvms
Type                       Name       Namespace     Status
VirtualMachine             testvm     default       <span class="nb">false
</span>VirtualMachineInstance     testvm     default       Scheduled
</code></pre></div></div>

<p>This is great, but there is an issue. The authentication method we used is your primary Kubernetes authentication. It has roles and permissions to do many different things in your k8s cluster. Wouldn’t it be better if we could scope that authentication and ensure that your application had a dedicated account, with only the proper permissions to interact with just what your application will need. This is what Kubernetes <strong>Service Accounts</strong> are for.</p>

<p><a href="https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/">Service Accounts</a> are accounts for processes as opposed to users. By default they are scoped to a namespace, but you can give service accounts access to other namespaces through RBAC rules that we will discuss later. In this demo, we will be using the “<em>default</em>” project/namespace, so the service account we create will be initially scoped only to this namespace.</p>

<p>Start by creating a new service account called “mykubevirtrunner” using your default Kubernetes account:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create sa mykubevirtrunner
<span class="nv">$ </span>kubectl describe sa mykubevirtrunner
Name:                mykubevirtrunner
Namespace:           default
Labels:              &lt;none&gt;
Annotations:         &lt;none&gt;
Image pull secrets:  &lt;none&gt;
Mountable secrets:   mykubevirtrunner-token-pd2mq
Tokens:              mykubevirtrunner-token-pd2mq
Events:              &lt;none&gt;
</code></pre></div></div>

<p>In the describe output you can see that a token and a mountable secret have been created. Let’s take a look at the contents of the secret:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe secret mykubevirtrunner-token-pd2mq
Name:         mykubevirtrunner-token-pd2mq
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: mykubevirtrunner
              kubernetes.io/service-account.uid: f401493b-658a-489d-bcce-0ccce39160a0

Type:  kubernetes.io/service-account-token

Data
<span class="o">====</span>
namespace:  7 bytes
token:      eyJhbGciOiJS...
ca.crt:     1111 bytes

</code></pre></div></div>

<p>The data listed for the “token” key is the information we will use in the next step, your output will be much longer, it has been truncated for this document. Ensure when copying the value that you get the entire token value.</p>

<h3 id="creating-a-kubeconfig-for-the-service-account">Creating a kubeconfig for the service account</h3>

<p>We will create a new kubeconfig file that leverages the service account and token we just created. The easiest way to do this is to create an empty kubeconfig file, and use the “<em>kubectl</em>” command to log in with the new token. Open a NEW terminal window. This will be the window we use for the service account. In this new terminal window start by setting the KUBECONFIG environment variable to point to a file in our local directory, and then using the “<em>kubectl</em>” command to generate a new kubeconfig file:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/sa-kubeconfig
kubectl config set-cluster minikube <span class="nt">--server</span><span class="o">=</span>https://&lt;update IP address&gt;:8443 <span class="nt">--insecure-skip-tls-verify</span>
kubectl config set-credentials mykubevirtrunner <span class="nt">--token</span><span class="o">=</span>&lt;<span class="nb">paste </span>token from last step here&gt;
kubectl config set-context minikube <span class="nt">--cluster</span><span class="o">=</span>minikube <span class="nt">--namespace</span><span class="o">=</span>default <span class="nt">--user</span><span class="o">=</span>mykubevirtrunner
kubectl config use-context minikube
</code></pre></div></div>

<p>We can test that the new kubeconfig file is working by running a kubectl command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods
Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: pods is forbidden: User <span class="s2">"system:serviceaccount:default:mykubevirtrunner"</span> cannot list resource <span class="s2">"pods"</span> <span class="k">in </span>API group <span class="s2">""</span> <span class="k">in </span>the namespace <span class="s2">"default"</span>
</code></pre></div></div>

<p>Note that the “User” is now listed as “<em>system:serviceaccount:default:mykubevirtrunner</em>” so we know we are using our new service account. Now try running our test program and note that it is using the service account as well:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>listvms/listvms
2021/07/07 14:53:23 cannot obtain KubeVirt vm list: virtualmachines.kubevirt.io is forbidden: User <span class="s2">"system:serviceaccount:default:mykubevirtrunner"</span> cannot list resource <span class="s2">"virtualmachines"</span> <span class="k">in </span>API group <span class="s2">"kubevirt.io"</span> <span class="k">in </span>the namespace <span class="s2">"default"</span>
</code></pre></div></div>

<p>You can see we are now using our service account in our application, but that service account doesn’t have the right permissions… We now need to assign a role to our service account to give it the proper API access. We will start simple and give the service account the <strong>kubevirt.io:view</strong> role, which will allow the service account to see the KubeVirt objects within the “<em>default</em>” namespace:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create clusterrolebinding kubevirt-viewer <span class="nt">--clusterrole</span><span class="o">=</span>kubevirt.io:view <span class="nt">--serviceaccount</span><span class="o">=</span>default:mykubevirtrunner
clusterrolebinding.rbac.authorization.k8s.io/kubevirt-viewer created
</code></pre></div></div>

<p>Now run the <em>listvms</em> command again:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./listvms/listvms
Type                       Name                    Namespace     Status
VirtualMachineInstance     vm-fedora-ephemeral     myvms         Running
</code></pre></div></div>

<p>Success! Our application is now using the service account that we created for authentication to the cluster. The service account can be extended by adding additional default roles to the account, or by creating custom roles that limit the scope of the service account to only the exact actions you want to take. When you install KubeVirt you get a set of default roles including “View”, “Edit” and “Admin”. Additional details about these roles are available here: <a href="https://kubevirt.io/user-guide/operations/authorization/">KubeVirt Default RBAC Cluster Roles</a></p>

<h2 id="running-in-a-kubernetes-cluster">Running in a Kubernetes Cluster</h2>

<p>So all of this is great if you want to run the application outside of your cluster … but what if you want your application to run INSIDE you cluster. You could create a kubeconfig file, and add it to your namespace as a secret and then mount that secret as a volume inside your pod, but there is an easier way that continues to leverage the service account that we created. By default Kubernetes creates a few environment variables for every pod that indicate that the container is running within Kubernetes, and it makes a Kubernetes authentication token for the service account that the container is running as available at /var/run/secrets/kubernetes.io/serviceaccount/token. The client-go KubeVirt library can detect that it is running inside a Kubernetes hosted container and will transparently use the authentication token provided with no additional configuration needed.</p>

<p>A container image with the listvms binary is available at <strong>quay.io/markd/listvms</strong>. We can start a copy of this container using the deployment yaml file located in the ‘listvms/listvms_deployment.yaml’ file.</p>

<p>Switch back to your original terminal window that is using your primary kubeconfig file, and using the “<em>kubectl</em>” command deploy one instance of the test pod, and then check the logs of the pod:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create <span class="nt">-f</span> listvms/listvms_deployment.yaml
<span class="nv">$ </span>kubectl get pods
NAME                                      READY   STATUS    RESTARTS   AGE
listvms-7b8f865c8d-2zqqn                  1/1     Running   0          7m30s
virt-launcher-vm-fedora-ephemeral-4ljg4   2/2     Running   0          24h
<span class="nv">$ </span>kubectl logs listvms-7b8f865c8d-2zqqn
2021/07/07 19:06:42 cannot obtain KubeVirt vm list: virtualmachines.kubevirt.io is forbidden: User <span class="s2">"system:serviceaccount:default:default"</span> cannot list resource <span class="s2">"virtualmachines"</span> <span class="k">in </span>API group <span class="s2">"kubevirt.io"</span> <span class="k">in </span>the namespace <span class="s2">"default"</span>
</code></pre></div></div>

<blockquote>
  <p><strong>NOTE:</strong> Be sure to deploy this demo application in a namespace that contains at least one running VM or VMI.</p>
</blockquote>

<p>The application is unable to run the operation, because it is running as the default service account in the “<em>default</em>” namespace. If you remember previously we created a service account in this namespace called “mykubevirtrunner”. We need only update the deployment to use this service account and we should see some success. Use the “kubectl edit deployment/listvms” command to update the container spec to include the “serviceAccount: mykubevirtrunner” line as show below:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">listvms</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/markd/listvms</span>
      <span class="na">serviceAccount</span><span class="pi">:</span> <span class="s">mykubevirtrunner</span>
      <span class="na">securityContext</span><span class="pi">:</span> <span class="pi">{}</span>
      <span class="na">schedulerName</span><span class="pi">:</span> <span class="s">default-scheduler</span>
</code></pre></div></div>

<p>This change will trigger Kubernetes to redeploy your pod, using the new serviceAccount. We should now see some output from our program:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods
NAME                                      READY   STATUS    RESTARTS   AGE
listvms-7b8f865c8d-2qzzn                  1/1     Running   0          7m30s
virt-launcher-vm-fedora-ephemeral-4ljg4   2/2     Running   0          24h
<span class="nv">$ </span>kubectl logs listvms-7b8f865c8d-2qzzn
Type                       Name                    Namespace     Status
VirtualMachineInstance     vm-fedora-ephemeral     myvms         Running
awaiting signal
</code></pre></div></div>

<h2 id="extending-rbac-role-across-namespaces">Extending RBAC Role across Namespaces</h2>

<p>As currently configured, the mykubevirtrunner service account can only “view” KubeVirt resources within its own namespace. If we want to extend that ability to other namespaces, we can add the view role for other namespaces to the mykubevirtrunner serviceAccount.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create namespace myvms
&lt;launch an addition vm here&gt;
kubectl create clusterrolebinding kubevirt-viewer <span class="nt">--clusterrole</span><span class="o">=</span>kubevirt.io:view <span class="nt">--serviceaccount</span><span class="o">=</span>default:mykubevirtrunner <span class="nt">-n</span> myvms
</code></pre></div></div>

<p>We can test that the ServiceAccount has been updated to also have permissions to view in the “myvms” namespace by running our listvms command one more time, this time passing in the optional flag <em>–namespaces</em>. Switch to your terminal window that is using the service account kubeconfig file and run the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>listvms/listvms <span class="nt">--namespaces</span> myvms
additional namespaces to check are:  myvms
Checking the following namespaces:  <span class="o">[</span>default myvms]
Type                       Name       Namespace     Status
VirtualMachine             testvm     default       <span class="nb">false
</span>VirtualMachineInstance     testvm     default       Scheduled
VirtualMachine             testvm     myvms         <span class="nb">false</span>
</code></pre></div></div>

<p>You can see that now, the ServiceAccount can view the vm and vmi that are in both the default namespace as well as the <em>myvms</em> namespace.</p>

<h2 id="creating-custom-rbac-roles">Creating Custom RBAC Roles</h2>

<p>In this demo we used RBAC roles created as part of the KubeVirt install. You can also create custom RBAC roles for KubeVirt. Documentation on how this can be done is available in the KubeVirt documentation <a href="https://kubevirt.io/user-guide/operations/authorization/#creating-custom-rbac-roles">Creating Custom RBAC Roles</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>It is possible to control and manage your KubeVirt machines with the use of Kubernetes service accounts and the “client-go” library. When using service accounts, you want to ensure that the account has the minimum role or permissions to do it’s job to ensure the security of your cluster. The “client-go” library gives you options on how you authenticate with your Kubernetes cluster, allowing you to deploy your application both in and out of your Kubernetes cluster.</p>

<h2 id="references">References</h2>

<p><a href="https://github.com/kubevirt/client-go">KubeVirt Client Go</a></p>

<p><a href="https://kubevirt.io/2018/KubeVirt-API-Access-Control.html">KubeVirt API Access Control</a></p>

<p><a href="https://kubevirt.io/user-guide/operations/authorization/">KubeVirt Default RBAC Cluster Roles</a></p>]]></content><author><name>Mark DeNeve</name></author><category term="news" /><category term="kubevirt" /><category term="go" /><category term="api" /><category term="authentication" /><summary type="html"><![CDATA[This blog post discusses authentication methods that can be used with the KubeVirt client-go library.]]></summary></entry><entry><title type="html">Using Intel vGPUs with Kubevirt</title><link href="https://kubevirt.io//2021/intel-vgpu-kubevirt.html" rel="alternate" type="text/html" title="Using Intel vGPUs with Kubevirt" /><published>2021-04-30T00:00:00+00:00</published><updated>2021-04-30T00:00:00+00:00</updated><id>https://kubevirt.io//2021/intel-vgpu-kubevirt</id><content type="html" xml:base="https://kubevirt.io//2021/intel-vgpu-kubevirt.html"><![CDATA[<!-- TOC depthFrom:2 insertAnchor:false orderedList:false updateOnSave:true withLinks:true -->
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisites">Prerequisites</a>
    <ul>
      <li><a href="#fedora-workstation-prep">Fedora Workstation Prep</a></li>
      <li><a href="#preparing-the-intel-vgpu-driver">Preparing the Intel vGPU driver</a></li>
    </ul>
  </li>
  <li><a href="#install-kubernetes-with-minikube">Install Kubernetes with minikube</a></li>
  <li><a href="#install-kubevirt">Install kubevirt</a>
    <ul>
      <li><a href="#validate-vgpu-detection">Validate vGPU detection</a></li>
      <li><a href="#install-containerize-data-importer">Install Containerize Data Importer</a></li>
    </ul>
  </li>
  <li><a href="#install-windows">Install Windows</a></li>
  <li><a href="#accessing-the-windows-vm">Accessing the Windows VM</a></li>
  <li><a href="#using-the-gpu">Using the GPU</a>
<!-- /TOC --></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Graphical User Interfaces (GUIs) have come along way over the past few years and most modern desktop environments expect some form of GPU acceleration in order to give you a seamless user experience. If you have tried running things like Windows 10 within Kubevirt you may have noticed that the desktop experience felt a little slow. This is due to Windows 10 reliance on GPU acceleration. In addition many applications are also now taking advantage of GPU acceleration and it can even be used in web based applications such as “FishGL”:
<br /></p>

<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-nogpu.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-nogpu.png" itemprop="thumbnail" width="100%" alt="FishGL" />
    </a>
    <figcaption itemprop="caption description"></figcaption>
  </figure>
</div>

<p>Without GPU hardware acceleration the user experience of a Virtual machine can be greatly impacted.</p>

<p>Starting with 5th generation Intel Core processors that have embedded Intel graphics processing units it is possible to share the graphics processor between multiple virtual machines. In Linux, this sharing of a GPU is typically enabled through the use of mediated GPU devices, also known as vGPUs. Kubevirt has supported the use of GPUs including GPU passthrough and vGPU since v0.22.0 back in 2019. This support was centered around one specific vendor, and only worked with expensive enterprise class cards and required additional licensing. Starting with <a href="https://github.com/kubevirt/kubevirt/releases/tag/v0.40.0">Kubevirt 0.40</a> support for detecting and allocating the Intel based vGPUs has been added to Kubevirt. Support for the creation of these virtualized Intel GPUs is available in the Linux Kernel since the 4.19 release. What does this meaning for you? You no longer need additional drivers or licenses to test out GPU accelerated virtual machines.</p>

<p>The total number of Intel vGPUs you can create is dependent on your specific hardware as well as support for changing the Graphics aperture size and shared graphics memory within your BIOS. For more details on this see <a href="https://github.com/intel/gvt-linux/wiki/GVTg_Setup_Guide#53-create-vgpu-kvmgt-only">Create vGPU (KVMGT only)</a> in the Intel GVTg wiki. Minimally configured devices can typically make at least two vGPU devices.</p>

<p>You can reproduce this work on any Kubernetes cluster running kubevirt v0.40.0 or later, but the steps you need to take to load the kernel modules and enable the virtual devices will vary based on the underlying OS your Kubernetes cluster is running on. In order to demonstrate how you can enable this feature, we will use an all-in-one Kubernetes cluster built using Fedora 32 and minikube.</p>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">Note</p><p>This blog post is a more advanced topic and assumes some Linux and Kubernetes understanding.</p>


</div></div>
<h2 id="prerequisites">Prerequisites</h2>

<p>Before we begin you will need a few things to make use of the Intel GPU:</p>

<ul>
  <li>A workstation or server with a 5th Generation or higher Intel Core Processor, or E3_v4 or higher Xeon Processor and enough memory to virtualize one or more VMs</li>
  <li>A preinstalled Fedora 32 Workstation with at least 50Gb of free space in the “/” filesystem</li>
  <li>The following software:
    <ul>
      <li>minikube - See <a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a></li>
      <li>virtctl - See <a href="https://github.com/kubevirt/kubevirt/releases">kubevirt releases</a></li>
      <li>kubectl - See <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">Install and Set Up kubectl on Linux</a></li>
    </ul>
  </li>
  <li>A Windows 10 Install ISO Image - See <a href="https://www.microsoft.com/en-us/software-download/windows10">Download Windows 10 Disk Image</a></li>
</ul>

<h3 id="fedora-workstation-prep">Fedora Workstation Prep</h3>

<p>In order to use minikube on Fedora 32 we will be installing multiple applications that will be used throughout this demo. In addition we will be configuring the workstation to use cgroups v1 and we will be updating the firewall to allow proper communication to our Kubernetes cluster as well as any hosted applications. Finally we will be disabling SELinux per the minikube bare-metal install instructions:</p>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">Note</p><p>This post assumes that we are starting with a fresh install of Fedora 32. If you are using an existing configured Fedora 32 Workstation, you may have some software conflicts.</p>


</div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf update <span class="nt">-y</span>
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> pciutils podman podman-docker conntrack tigervnc rdesktop
<span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>ALL <span class="nt">--args</span><span class="o">=</span><span class="s2">"systemd.unified_cgroup_hierarchy=0"</span>
<span class="c"># Setup firewall rules to allow inbound and outbound connections from your minikube cluster</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>30000-65535/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>30000-65535/udp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>10250-10252/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>10248/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>2379-2380/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>6443/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>8443/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>9153/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-service</span><span class="o">=</span>dns <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-interface</span><span class="o">=</span>cni-podman0 <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-masquerade</span> <span class="nt">--permanent</span>
<span class="nb">sudo </span>vi /etc/selinux/config
<span class="c"># change the "SELINUX=enforcing" to "SELINUX=permissive"</span>
<span class="nb">sudo </span>setenforce 0
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>sshd <span class="nt">--now</span>
</code></pre></div></div>

<p>We will now install the CRIO runtime:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf module <span class="nb">enable</span> <span class="nt">-y</span> cri-o:1.18
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> cri-o cri-tools
<span class="nb">sudo </span>systemctl <span class="nb">enable</span> <span class="nt">--now</span> crio
</code></pre></div></div>

<h3 id="preparing-the-intel-vgpu-driver">Preparing the Intel vGPU driver</h3>

<p>In order to make use of the Intel vGPU driver, we need to make a few changes to our all-in-one host. The commands below assume you are using a Fedora based host. If you are using a different base OS, be sure to update your commands for that specific distribution.</p>

<p>The following commands will do the following:</p>

<ul>
  <li>load the kvmgt module to enable support within kvm</li>
  <li>enable gvt in the i915 module</li>
  <li>update the Linux kernel to enable Intel IOMMU</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>sh <span class="nt">-c</span> <span class="s2">"echo kvmgt &gt; /etc/modules-load.d/gpu-kvmgt.conf"</span>
<span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>ALL <span class="nt">--args</span><span class="o">=</span><span class="s2">"intel_iommu=on i915.enable_gvt=1"</span>
<span class="nb">sudo </span>shutdown <span class="nt">-r</span> now
</code></pre></div></div>

<p>After the reboot check to ensure that the proper kernel modules have been loaded:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>lsmod | <span class="nb">grep </span>kvmgt
kvmgt                  32768  0
mdev                   20480  2 kvmgt,vfio_mdev
vfio                   32768  3 kvmgt,vfio_mdev,vfio_iommu_type1
kvm                   798720  2 kvmgt,kvm_intel
i915                 2494464  4 kvmgt
drm                   557056  4 drm_kms_helper,kvmgt,i915
</code></pre></div></div>

<p>We will now create our vGPU devices. These virtual devices are created by echoing a GUID into a sys device created by the Intel driver. This needs to be done every time the system boots. The easiest way to do this is using a systemd service that runs on every boot. Before we create this systemd service, we need to validate the PCI ID of your Intel Graphics card. To do this we will use the <code class="language-plaintext highlighter-rouge">lspci</code> command</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>lspci
00:00.0 Host bridge: Intel Corporation Device 9b53 <span class="o">(</span>rev 03<span class="o">)</span>
00:02.0 VGA compatible controller: Intel Corporation Device 9bc8 <span class="o">(</span>rev 03<span class="o">)</span>
00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5/v6 / E3-1500 v5 / 6th/7th/8th Gen Core Processor Gaussian Mixture Model
</code></pre></div></div>

<p>Take note that in the above output the Intel GPU is on “00:02.0”. Now create the <code class="language-plaintext highlighter-rouge">/etc/systemd/system/gvtg-enable.service</code> but be sure to update the PCI ID as appropriate for your machine:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> ~/gvtg-enable.service <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
[Unit]
Description=Create Intel GVT-g vGPU

[Service]
Type=oneshot
ExecStart=/bin/sh -c "echo '56a4c4e2-c81f-4cba-82bf-af46c30ea32d' &gt; /sys/devices/pci0000:00/0000:00:02.0/mdev_supported_types/i915-GVTg_V5_8/create"
ExecStart=/bin/sh -c "echo '973069b7-2025-406b-b3c9-301016af3150' &gt; /sys/devices/pci0000:00/0000:00:02.0/mdev_supported_types/i915-GVTg_V5_8/create"
ExecStop=/bin/sh -c "echo '1' &gt; /sys/devices/pci0000:00/0000:00:02.0/56a4c4e2-c81f-4cba-82bf-af46c30ea32d/remove"
ExecStop=/bin/sh -c "echo '1' &gt; /sys/devices/pci0000:00/0000:00:02.0/973069b7-2025-406b-b3c9-301016af3150/remove"
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span><span class="nb">sudo mv</span> ~/gvtg-enable.service /etc/systemd/system/gvtg-enable.service
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>gvtg-enable <span class="nt">--now</span>
</code></pre></div></div>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">Note</p><p>The above systemd service will create two vGPU devices, you can repeat the commands with additional unique GUIDs up to a maximum of 8 vGPU if your particular hardware supports it.</p>


</div></div>
<p>We can validate that the vGPU devices were created by looking in the <code class="language-plaintext highlighter-rouge">/sys/devices/pci0000:00/0000:00:02.0/</code> directory.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lsa</span> /sys/devices/pci0000:00/0000:00:02.0/56a4c4e2-c81f-4cba-82bf-af46c30ea32d
total 0
lrwxrwxrwx. 1 root root    0 Apr 20 13:56 driver -&gt; ../../../../bus/mdev/drivers/vfio_mdev
drwxr-xr-x. 2 root root    0 Apr 20 14:41 intel_vgpu
lrwxrwxrwx. 1 root root    0 Apr 20 14:41 iommu_group -&gt; ../../../../kernel/iommu_groups/8
lrwxrwxrwx. 1 root root    0 Apr 20 14:41 mdev_type -&gt; ../mdev_supported_types/i915-GVTg_V5_8
drwxr-xr-x. 2 root root    0 Apr 20 14:41 power
<span class="nt">--w-------</span><span class="nb">.</span> 1 root root 4096 Apr 20 14:41 remove
lrwxrwxrwx. 1 root root    0 Apr 20 13:56 subsystem -&gt; ../../../../bus/mdev
<span class="nt">-rw-r--r--</span><span class="nb">.</span> 1 root root 4096 Apr 20 13:56 uevent
</code></pre></div></div>

<p>Note that “mdev_type” points to “i915-GVTg_V5_8”, this will come into play later when we configure kubevirt to detect the vGPU.</p>

<h2 id="install-kubernetes-with-minikube">Install Kubernetes with minikube</h2>

<p>We will now install Kubernetes onto our Fedora Workstation. <a href="https://minikube.sigs.k8s.io/docs/">Minikube</a> will help quickly set up our Kubernetes cluster environment. We will start by getting the latest release of minikube and kubectl.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-LO</span> https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
<span class="nb">sudo install </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="nv">VERSION</span><span class="o">=</span><span class="si">$(</span>minikube kubectl version | <span class="nb">head</span> <span class="nt">-1</span> | <span class="nb">awk</span> <span class="nt">-F</span><span class="s1">', '</span> <span class="o">{</span><span class="s1">'print $3'</span><span class="o">}</span> | <span class="nb">awk</span> <span class="nt">-F</span><span class="s1">':'</span> <span class="o">{</span><span class="s1">'print $2'</span><span class="o">}</span> | <span class="nb">sed </span>s/<span class="se">\"</span>//g<span class="si">)</span>
<span class="nb">sudo install</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.minikube/cache/linux/<span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span>/kubectl /usr/local/bin
</code></pre></div></div>

<p>We will be using the minikube driver “none” which will install Kubernetes directly onto this machine. This will allow you to maintain a copy of the virtual machines that you build through a reboot. Later in this post we will create persistent volumes for virtual machine storage in “/data”. As previously noted, ensure that you have at least 50Gb of free space in “/data” to complete this setup. The minikube install will take a few minutes to complete.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /data/winhd1-pv
<span class="nv">$ </span><span class="nb">sudo </span>minikube start <span class="nt">--driver</span><span class="o">=</span>none <span class="nt">--container-runtime</span><span class="o">=</span>crio
😄  minikube v1.19.0 on Fedora 32
✨  Using the none driver based on user configuration
👍  Starting control plane node minikube <span class="k">in </span>cluster minikube
🤹  Running on localhost <span class="o">(</span><span class="nv">CPUs</span><span class="o">=</span>12, <span class="nv">Memory</span><span class="o">=</span>31703MB, <span class="nv">Disk</span><span class="o">=</span>71645MB<span class="o">)</span> ...
ℹ️  OS release is Fedora 32 <span class="o">(</span>Workstation Edition<span class="o">)</span>
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.6 ...
    ▪ Generating certificates and keys ...
    ▪ Booting up control plane ...
    ▪ Configuring RBAC rules ...
🤹  Configuring <span class="nb">local </span>host environment ...
🔎  Verifying Kubernetes components...
    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use <span class="s2">"minikube"</span> cluster and <span class="s2">"default"</span> namespace by default
</code></pre></div></div>

<p>In order to make our interaction with Kubernetes a little easier, we will need to copy some files and update our <code class="language-plaintext highlighter-rouge">.kube/config</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.minikube/profiles/minikube
<span class="nb">sudo cp</span> <span class="nt">-r</span> /root/.kube /home/<span class="nv">$USER</span>
<span class="nb">sudo cp</span> /root/.minikube/ca.crt /home/<span class="nv">$USER</span>/.minikube/ca.crt
<span class="nb">sudo cp</span> /root/.minikube/profiles/minikube/client.crt /home/<span class="nv">$USER</span>/.minikube/profiles/minikube
<span class="nb">sudo cp</span> /root/.minikube/profiles/minikube/client.key /home/<span class="nv">$USER</span>/.minikube/profiles/minikube
<span class="nb">sudo chown</span> <span class="nt">-R</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /home/<span class="nv">$USER</span>/.kube
<span class="nb">sudo chown</span> <span class="nt">-R</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /home/<span class="nv">$USER</span>/.minikube
<span class="nb">sed</span> <span class="nt">-i</span>  <span class="s2">"s/root/home</span><span class="se">\/</span><span class="nv">$USER</span><span class="s2">/"</span> ~/.kube/config
</code></pre></div></div>

<p>Once the minikube install is complete, validate that everything is working properly.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get nodes
NAME       STATUS   ROLES                  AGE    VERSION
kubevirt   Ready    control-plane,master   4m5s   v1.20.2
</code></pre></div></div>

<p>As long as you don’t get any errors, your base Kubernetes cluster is ready to go.</p>

<h2 id="install-kubevirt">Install kubevirt</h2>

<p>Our all-in-one Kubernetes cluster is now ready for installing Installing Kubevirt. Using the minikube addons manager, we will install kubevirt into our cluster:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>minikube addons <span class="nb">enable </span>kubevirt
kubectl <span class="nt">-n</span> kubevirt <span class="nb">wait </span>kubevirt kubevirt <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available <span class="nt">--timeout</span><span class="o">=</span>300s
</code></pre></div></div>

<p>At this point, we need to update our instance of kubevirt in the cluster. We need to configure kubevirt to detect the Intel vGPU by giving it an <em>mdevNameSelector</em> to look for, and a <em>resourceName</em> to assign to it. The <em>mdevNameSelector</em> comes from the “mdev_type” that we identified earlier when we created the two virtual GPUs. When the kubevirt device manager finds instances of this mdev type, it will record this information and tag the node with the identified resourceName. We will use this resourceName later when we start up our virtual machine.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> kubevirt-patch.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
spec:
  configuration:
    developerConfiguration:
      featureGates:
      - GPU
    permittedHostDevices:
      mediatedDevices:
      - mdevNameSelector: "i915-GVTg_V5_8"
        resourceName: "intel.com/U630"
</span><span class="no">EOF
</span>kubectl patch kubevirt kubevirt <span class="nt">-n</span> kubevirt <span class="nt">--patch</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat </span>kubevirt-patch.yaml<span class="si">)</span><span class="s2">"</span> <span class="nt">--type</span><span class="o">=</span>merge
</code></pre></div></div>

<p>We now need to wait for kubevirt to reload its configuration.</p>

<h3 id="validate-vgpu-detection">Validate vGPU detection</h3>

<p>Now that kubevirt is installed and running, lets ensure that the vGPU was identified correctly. Describe the minikube node, using the command <code class="language-plaintext highlighter-rouge">kubectl describe node</code> and look for the “Capacity” section. If kubevirt properly detected the vGPU you will see an entry for “intel.com/U630” with a capacity value of greater than 0.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe node
Name:               kubevirt
Roles:              control-plane,master
Labels:             beta.kubernetes.io/arch<span class="o">=</span>amd64
                    beta.kubernetes.io/os<span class="o">=</span>linux
...
Capacity:
  cpu:                            12
  devices.kubevirt.io/kvm:        110
  devices.kubevirt.io/tun:        110
  devices.kubevirt.io/vhost-net:  110
  ephemeral-storage:              71645Mi
  hugepages-1Gi:                  0
  hugepages-2Mi:                  0
  intel.com/U630:                 2
  memory:                         11822640Ki
  pods:                           110
</code></pre></div></div>

<p>There it is, intel.com/U630 - two of them are available.  Now all we need is a virtual machine to consume them.</p>

<h3 id="install-containerize-data-importer">Install Containerize Data Importer</h3>

<p>In order to install Windows 10, we are going to need to upload a Windows 10 install ISO to the cluster. This can be facilitated through the use of the Containerized Data Importer. The following steps are taken from the <a href="https://kubevirt.io/labs/kubernetes/lab2.html">Experiment with the Containerized Data Importer (CDI)</a> web page:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">VERSION</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-s</span> https://github.com/kubevirt/containerized-data-importer/releases/latest | <span class="nb">grep</span> <span class="nt">-o</span> <span class="s2">"v[0-9]</span><span class="se">\.</span><span class="s2">[0-9]*</span><span class="se">\.</span><span class="s2">[0-9]*"</span><span class="si">)</span>
kubectl create <span class="nt">-f</span> https://github.com/kubevirt/containerized-data-importer/releases/download/<span class="nv">$VERSION</span>/cdi-operator.yaml
kubectl create <span class="nt">-f</span> https://github.com/kubevirt/containerized-data-importer/releases/download/<span class="nv">$VERSION</span>/cdi-cr.yaml
kubectl <span class="nt">-n</span> cdi <span class="nb">wait </span>cdi cdi <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available <span class="nt">--timeout</span><span class="o">=</span>300s
</code></pre></div></div>

<p>Now that our CDI is available, we will expose it for consumption using a nodePort. This will allow us to connect to the cdi-proxy in the next steps.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> cdi-nodeport.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: Service
metadata:
  name: cdi-proxy-nodeport
  namespace: cdi
spec:
  type: NodePort
  selector:
    cdi.kubevirt.io: cdi-uploadproxy
  ports:
    - port: 8443
      nodePort: 30443
</span><span class="no">EOF
</span>kubectl create <span class="nt">-f</span> cdi-nodeport.yaml
</code></pre></div></div>

<p>One final step, lets get the latest release of virtctl which we will be using as we install Windows.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">VERSION</span><span class="o">=</span><span class="si">$(</span>kubectl get kubevirt.kubevirt.io/kubevirt <span class="nt">-n</span> kubevirt <span class="nt">-o</span><span class="o">=</span><span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.status.observedKubeVirtVersion}"</span><span class="si">)</span>
curl <span class="nt">-L</span> <span class="nt">-o</span> virtctl https://github.com/kubevirt/kubevirt/releases/download/<span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span>/virtctl-<span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span><span class="nt">-linux-amd64</span>
<span class="nb">sudo install </span>virtctl /usr/local/bin
</code></pre></div></div>

<h2 id="install-windows">Install Windows</h2>

<p>At this point we can now install a Windows VM in order to test this feature. The steps below are based on <a href="https://kubevirt.io/2020/KubeVirt-installing_Microsoft_Windows_from_an_iso.html">KubeVirt: installing Microsoft Windows from an ISO</a> however we will be using Windows 10 instead of Windows Server 2012. The commands below assume that you have a Windows 10 ISO file called <code class="language-plaintext highlighter-rouge">win10-virtio.iso</code>. If you need a Windows 10 CD, please see <a href="https://www.microsoft.com/en-us/software-download/windows10">Download Windows 10 Disk Image</a> and come back here after you have obtained your install CD.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>virtctl image-upload <span class="se">\</span>
   <span class="nt">--image-path</span><span class="o">=</span>win10-virtio.iso <span class="se">\</span>
   <span class="nt">--pvc-name</span><span class="o">=</span>iso-win10 <span class="se">\</span>
   <span class="nt">--access-mode</span><span class="o">=</span>ReadWriteOnce <span class="se">\</span>
   <span class="nt">--pvc-size</span><span class="o">=</span>6G <span class="se">\</span>
   <span class="nt">--uploadproxy-url</span><span class="o">=</span>https://127.0.0.1:30443 <span class="se">\</span>
   <span class="nt">--insecure</span> <span class="se">\</span>
   <span class="nt">--wait-secs</span><span class="o">=</span>240
</code></pre></div></div>

<p>We need a place to store our Windows 10 virtual disk, use the following to create a 40Gb space to store our file. In order to do this within minikube we will manually create a PersistentVolume (PV) as well as a PersistentVolumeClaim (PVC). These steps assume that you have 45+ GiB of free space in “/”.  We will create a “/data” directory as well as a subdirectory for storing our PV. If you do not have at least 45 GiB of free space in “/”, you will need to free up space, or mount storage on “/data” to continue.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> win10-pvc.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pvwinhd1
spec:
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 43Gi
  claimRef:
    namespace: default
    name: winhd1
  hostPath:
    path: /data/winhd1-pv
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: winhd1
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 40Gi
</span><span class="no">EOF
</span>kubectl create <span class="nt">-f</span> win10-pvc.yaml
</code></pre></div></div>

<p>We can now create our Windows 10 virtual machine. Use the following to create a virtual machine definition file that includes a vGPU:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> win10vm1.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: kubevirt.io/v1alpha3
kind: VirtualMachine
metadata:
  name: win10vm1
spec:
  running: false
  template:
    metadata:
      creationTimestamp: null
      labels:
        kubevirt.io/domain: win10vm1
    spec:
      domain:
        clock:
          timer:
            hpet:
              present: false
            hyperv: {}
            pit:
              tickPolicy: delay
            rtc:
              tickPolicy: catchup
          utc: {}
        cpu:
          cores: 1
          sockets: 2
          threads: 1
        devices:
          gpus:
          - deviceName: intel.com/U630
            name: gpu1
          disks:
          - cdrom:
              bus: sata
            name: windows-guest-tools
          - bootOrder: 1
            cdrom:
              bus: sata
            name: cdrom
          - bootOrder: 2
            disk:
              bus: sata
            name: disk-1
          inputs:
          - bus: usb
            name: tablet
            type: tablet
          interfaces:
          - masquerade: {}
            model: e1000e
            name: nic-0
        features:
          acpi: {}
          apic: {}
          hyperv:
            relaxed: {}
            spinlocks:
              spinlocks: 8191
            vapic: {}
        machine:
          type: pc-q35-rhel8.2.0
        resources:
          requests:
            memory: 8Gi
      hostname: win10vm1
      networks:
      - name: nic-0
        pod: {}
      terminationGracePeriodSeconds: 3600
      volumes:
        - name: cdrom
          persistentVolumeClaim:
            claimName: iso-win10
        - name: disk-1
          persistentVolumeClaim:
            claimName: winhd1
        - containerDisk:
            image: quay.io/kubevirt/virtio-container-disk
          name: windows-guest-tools
</span><span class="no">EOF
</span>kubectl create <span class="nt">-f</span> win10vm1.yaml
</code></pre></div></div>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">NOTE</p><p>This VM is not optimized to use virtio devices to simplify the OS install. By using SATA devices as well as an emulated e1000 network card, we do not need to worry about loading additional drivers.</p>


</div></div>
<p>The key piece of information that we have added to this virtual machine definition is this snippet of yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="na">devices</span><span class="pi">:</span>
          <span class="na">gpus</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">deviceName</span><span class="pi">:</span> <span class="s">intel.com/U630</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">gpu1</span>
</code></pre></div></div>

<p>Here we are identifying the gpu device that we want to attach to this VM. The deviceName relates back to the name that we gave to kubevirt to identify the Intel GPU resources. It also is the same identifier that shows up in the “Capacity” section of a node when you run <code class="language-plaintext highlighter-rouge">kubectl describe node</code>.</p>

<p>We can now start the virtual machine:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl start win10vm1
kubectl get vmi <span class="nt">--watch</span>
</code></pre></div></div>

<p>When the output of shows that the vm is in a “Running” phase you can “CTRL+C” to end the watch command.</p>

<h2 id="accessing-the-windows-vm">Accessing the Windows VM</h2>

<p>Since we are running this VM on this local machine, we can now take advantage of the virtctl command to connect to the VNC console of the virtual machine.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl vnc win10vm1
</code></pre></div></div>

<p>A new VNC Viewer window will open and you should now see the Windows 10 install screen. Follow standard Windows 10 install steps at this point.</p>

<p>Once the install is complete you have a Windows 10 VM running with a GPU available. You can test that GPU acceleration is available by opening the Windows 10 task manager, selecting Advanced and then select the “Performance” tab. Note that the first time you start up, Windows is still detecting and installing the appropriate drivers. It may take a minute or two for the GPU information to show up in the Performance tab.</p>

<p>Try testing out the GPU acceleration. Open a web browser in your VM and navigate to “https://webglsamples.org/fishtank/fishtank.html” HOWEVER don’t be surprised by the poor performance. The default kubevirt console does not take advantage of the GPU. For that we need to take one final step to use the Windows Remote Desktop Protocol (RDP) which can use the GPU.</p>

<h2 id="using-the-gpu">Using the GPU</h2>

<p>In order to take advantage of the virtual GPU we have added, we will need to connect to the virtual machine over Remote Desktop Protocol (RDP). Follow these steps to enable RDP:</p>

<ol>
  <li>In the Windows 10 search bar, type “<strong>Remote Desktop Settings</strong>” and then open the result.</li>
  <li>Select “<strong>Enable Remote Desktop</strong>” and confirm the change.</li>
  <li>Select “<strong>Advanced settings</strong>” and un-check “<strong>Require computers to use Network level Authentication</strong>”, and confirm this change.</li>
  <li>Finally reboot the Windows 10 Virtual machine.</li>
</ol>

<p>Now, run the following commands in order to expose the RDP server to outside your Kubernetes cluster:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>virtctl expose vm win10vm1 <span class="nt">--port</span><span class="o">=</span>3389 <span class="nt">--type</span><span class="o">=</span>NodePort <span class="nt">--name</span><span class="o">=</span>win10vm1-rdp
<span class="nv">$ </span>kubectl get svc
NAME           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>          AGE
kubernetes     ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          18h
win10vm1-rdp   NodePort    10.105.159.184   &lt;none&gt;        3389:30627/TCP   39s
</code></pre></div></div>

<p>Note the port that was assigned to this service we will use it in the next step. In the above output the port is 30627.</p>

<p>We can now use the rdesktop tool to connect to our VM and get the full advantages of the vGPU. From a command line run <code class="language-plaintext highlighter-rouge">rdesktop localhost:&lt;port&gt;</code> being sure to update the port based on the output from above. When prompted by rdesktop accept the certificate. Log into your Windows 10 client. You can now test out the vGPU.</p>

<p>Let’s try FishGL again. Open a browser and go to <a href="https://webglsamples.org/fishtank/fishtank.html">https://webglsamples.org/fishtank/fishtank.html</a>. You should notice a large improvement in the applications performance. You can also open the Task Manager and look at the performance tab to see the GPU under load.
<br /></p>

<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-gpu.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-gpu.png" itemprop="thumbnail" width="100%" alt="FishGL" />
    </a>
    <figcaption itemprop="caption description"></figcaption>
  </figure>
</div>

<p>Note that since you are running your Fedora 32 workstation on this same GPU you are already sharing the graphics workload between your primary desktop, and the virtualized Windows Desktop also running on this machine.</p>

<p>Congratulations! You now have a VM running in Kubernetes using an Intel vGPU. If your test machine has enough resources you can repeat the steps and create multiple virtual machines all sharing the one Intel GPU.</p>]]></content><author><name>Mark DeNeve</name></author><category term="news" /><category term="kubevirt" /><category term="vGPU" /><category term="Windows" /><category term="GPU" /><category term="Intel" /><category term="minikube" /><category term="Fedora" /><summary type="html"><![CDATA[This blog post guides users on how to improve VM graphics performance using Intel Core processors, GPU Virtualization and Kubevirt.]]></summary></entry><entry><title type="html">Automated Windows Installation With Tekton Pipelines</title><link href="https://kubevirt.io//2021/Automated-Windows-Installation-With-Tekton-Pipelines.html" rel="alternate" type="text/html" title="Automated Windows Installation With Tekton Pipelines" /><published>2021-04-21T00:00:00+00:00</published><updated>2021-04-21T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Automated-Windows-Installation-With-Tekton-Pipelines</id><content type="html" xml:base="https://kubevirt.io//2021/Automated-Windows-Installation-With-Tekton-Pipelines.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This blog shows how we can easily automate a process of installing Windows VMs on KubeVirt with <a href="https://github.com/tektoncd/pipeline">Tekton Pipelines</a>.</p>

<p>Tekton Pipelines can be used to create a single <code class="language-plaintext highlighter-rouge">Pipeline</code> that encapsulates the installation process which can be run and replicated with <code class="language-plaintext highlighter-rouge">PipelineRuns</code>.
The pipeline will be built with <a href="https://github.com/kubevirt/kubevirt-tekton-tasks">KubeVirt Tekton Tasks</a>, which includes all the necessary tasks for this example.</p>

<h2 id="pipeline-description">Pipeline Description</h2>

<p>The pipeline will prepare an empty Persistent Volume Claim (PVC) and download a Windows source ISO into another PVC. Both of them will be initialized with Containerized Data Importer (CDI).
It will then spin up an installation VM and use Windows Answer Files to automatically install the VM.
Then the pipeline will wait for the installation to complete and will delete the installation VM while keeping the artifact PVC with the installed operating system.
You can later use the artifact PVC as a base image and copy it for new VMs.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
  <li>KubeVirt <code class="language-plaintext highlighter-rouge">v0.39.0</code></li>
  <li>Tekton Pipelines <code class="language-plaintext highlighter-rouge">v0.19.0</code></li>
  <li>KubeVirt Tekton Tasks <code class="language-plaintext highlighter-rouge">v0.3.0</code></li>
</ul>

<h2 id="running-windows-installer-pipeline">Running Windows Installer Pipeline</h2>

<h2 id="obtaining-a-url-of-windows-source-iso">Obtaining a URL of Windows Source ISO</h2>

<p>First we have to obtain a Download URL of Windows Source ISO.</p>

<ol>
  <li>Go to <a href="https://www.microsoft.com/en-us/software-download/windows10ISO">https://www.microsoft.com/en-us/software-download/windows10ISO</a>. You can also obtain a server edition for evaluation at <a href="https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2019">https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2019</a>.</li>
  <li>Fill in the edition and <code class="language-plaintext highlighter-rouge">English</code> language (other languages need to be updated in windows-10-autounattend ConfigMap below) and go to the download page.</li>
  <li>Right-click on the 64-bit download button and copy the download link. The link should be valid for 24 hours.  We will need this URL a bit later when running the pipeline.</li>
</ol>

<h2 id="preparing-autounattendxml-configmap">Preparing autounattend.xml ConfigMap</h2>

<p>Now we have to prepare our autounattend.xml Answer File with the installation instructions. We will store it in a <code class="language-plaintext highlighter-rouge">ConfigMap</code>, but optionally it can be stored in a <code class="language-plaintext highlighter-rouge">Secret</code> as well.</p>

<p>The configuration file can be generated with <a href="https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/wsim/windows-system-image-manager-overview-topics">Windows SIM</a>
or it can be specified manually according to <a href="https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/wsim/answer-files-overview">Answer File Reference</a>
and <a href="https://docs.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/components-b-unattend">Answer File Components Reference</a>.</p>

<p>The following config map includes the required drivers and guest disk configuration.
It also specifies how the installation should proceed and what users should be created.
In our case it is an <code class="language-plaintext highlighter-rouge">Administrator</code> user with <code class="language-plaintext highlighter-rouge">changepassword</code> password.
You can also change the Answer File according to your needs by consulting the already mentioned documentation.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">windows-10-autounattend</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">Autounattend.xml</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
    <span class="s">&lt;unattend xmlns="urn:schemas-microsoft-com:unattend"&gt;</span>
        <span class="s">&lt;settings pass="windowsPE"&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-PnpCustomizationsWinPE" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State"&gt;</span>
                <span class="s">&lt;DriverPaths&gt;</span>
                    <span class="s">&lt;PathAndCredentials wcm:action="add" wcm:keyValue="1"&gt;</span>
                        <span class="s">&lt;Path&gt;E:\viostor\w10\amd64&lt;/Path&gt;</span>
                    <span class="s">&lt;/PathAndCredentials&gt;</span>
                    <span class="s">&lt;PathAndCredentials wcm:action="add" wcm:keyValue="2"&gt;</span>
                        <span class="s">&lt;Path&gt;E:\NetKVM\w10\amd64&lt;/Path&gt;</span>
                    <span class="s">&lt;/PathAndCredentials&gt;</span>
                    <span class="s">&lt;PathAndCredentials wcm:action="add" wcm:keyValue="3"&gt;</span>
                        <span class="s">&lt;Path&gt;E:\viorng\w10\amd64&lt;/Path&gt;</span>
                    <span class="s">&lt;/PathAndCredentials&gt;</span>
                <span class="s">&lt;/DriverPaths&gt;</span>
            <span class="s">&lt;/component&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;SetupUILanguage&gt;</span>
                    <span class="s">&lt;UILanguage&gt;en-US&lt;/UILanguage&gt;</span>
                <span class="s">&lt;/SetupUILanguage&gt;</span>
                <span class="s">&lt;InputLocale&gt;0409:00000409&lt;/InputLocale&gt;</span>
                <span class="s">&lt;SystemLocale&gt;en-US&lt;/SystemLocale&gt;</span>
                <span class="s">&lt;UILanguage&gt;en-US&lt;/UILanguage&gt;</span>
                <span class="s">&lt;UILanguageFallback&gt;en-US&lt;/UILanguageFallback&gt;</span>
                <span class="s">&lt;UserLocale&gt;en-US&lt;/UserLocale&gt;</span>
            <span class="s">&lt;/component&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;DiskConfiguration&gt;</span>
                    <span class="s">&lt;Disk wcm:action="add"&gt;</span>
                        <span class="s">&lt;CreatePartitions&gt;</span>
                            <span class="s">&lt;CreatePartition wcm:action="add"&gt;</span>
                                <span class="s">&lt;Order&gt;1&lt;/Order&gt;</span>
                                <span class="s">&lt;Type&gt;Primary&lt;/Type&gt;</span>
                                <span class="s">&lt;Size&gt;100&lt;/Size&gt;</span>
                            <span class="s">&lt;/CreatePartition&gt;</span>
                            <span class="s">&lt;CreatePartition wcm:action="add"&gt;</span>
                                <span class="s">&lt;Extend&gt;true&lt;/Extend&gt;</span>
                                <span class="s">&lt;Order&gt;2&lt;/Order&gt;</span>
                                <span class="s">&lt;Type&gt;Primary&lt;/Type&gt;</span>
                            <span class="s">&lt;/CreatePartition&gt;</span>
                        <span class="s">&lt;/CreatePartitions&gt;</span>
                        <span class="s">&lt;ModifyPartitions&gt;</span>
                            <span class="s">&lt;ModifyPartition wcm:action="add"&gt;</span>
                                <span class="s">&lt;Active&gt;true&lt;/Active&gt;</span>
                                <span class="s">&lt;Format&gt;NTFS&lt;/Format&gt;</span>
                                <span class="s">&lt;Label&gt;System Reserved&lt;/Label&gt;</span>
                                <span class="s">&lt;Order&gt;1&lt;/Order&gt;</span>
                                <span class="s">&lt;PartitionID&gt;1&lt;/PartitionID&gt;</span>
                                <span class="s">&lt;TypeID&gt;0x27&lt;/TypeID&gt;</span>
                            <span class="s">&lt;/ModifyPartition&gt;</span>
                            <span class="s">&lt;ModifyPartition wcm:action="add"&gt;</span>
                                <span class="s">&lt;Active&gt;true&lt;/Active&gt;</span>
                                <span class="s">&lt;Format&gt;NTFS&lt;/Format&gt;</span>
                                <span class="s">&lt;Label&gt;OS&lt;/Label&gt;</span>
                                <span class="s">&lt;Letter&gt;C&lt;/Letter&gt;</span>
                                <span class="s">&lt;Order&gt;2&lt;/Order&gt;</span>
                                <span class="s">&lt;PartitionID&gt;2&lt;/PartitionID&gt;</span>
                            <span class="s">&lt;/ModifyPartition&gt;</span>
                        <span class="s">&lt;/ModifyPartitions&gt;</span>
                        <span class="s">&lt;DiskID&gt;0&lt;/DiskID&gt;</span>
                        <span class="s">&lt;WillWipeDisk&gt;true&lt;/WillWipeDisk&gt;</span>
                    <span class="s">&lt;/Disk&gt;</span>
                <span class="s">&lt;/DiskConfiguration&gt;</span>
                <span class="s">&lt;ImageInstall&gt;</span>
                    <span class="s">&lt;OSImage&gt;</span>
                        <span class="s">&lt;InstallTo&gt;</span>
                            <span class="s">&lt;DiskID&gt;0&lt;/DiskID&gt;</span>
                            <span class="s">&lt;PartitionID&gt;2&lt;/PartitionID&gt;</span>
                        <span class="s">&lt;/InstallTo&gt;</span>
                        <span class="s">&lt;InstallToAvailablePartition&gt;false&lt;/InstallToAvailablePartition&gt;</span>
                    <span class="s">&lt;/OSImage&gt;</span>
                <span class="s">&lt;/ImageInstall&gt;</span>
                <span class="s">&lt;UserData&gt;</span>
                    <span class="s">&lt;AcceptEula&gt;true&lt;/AcceptEula&gt;</span>
                    <span class="s">&lt;FullName&gt;Administrator&lt;/FullName&gt;</span>
                    <span class="s">&lt;Organization&gt;&lt;/Organization&gt;</span>
                    <span class="s">&lt;ProductKey&gt;</span>
                        <span class="s">&lt;Key&gt;W269N-WFGWX-YVC9B-4J6C9-T83GX&lt;/Key&gt;</span>
                    <span class="s">&lt;/ProductKey&gt;</span>
                <span class="s">&lt;/UserData&gt;</span>
            <span class="s">&lt;/component&gt;</span>
        <span class="s">&lt;/settings&gt;</span>
        <span class="s">&lt;settings pass="offlineServicing"&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-LUA-Settings" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;EnableLUA&gt;false&lt;/EnableLUA&gt;</span>
            <span class="s">&lt;/component&gt;</span>
        <span class="s">&lt;/settings&gt;</span>
        <span class="s">&lt;settings pass="generalize"&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-Security-SPP" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;SkipRearm&gt;1&lt;/SkipRearm&gt;</span>
            <span class="s">&lt;/component&gt;</span>
        <span class="s">&lt;/settings&gt;</span>
        <span class="s">&lt;settings pass="specialize"&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;InputLocale&gt;0409:00000409&lt;/InputLocale&gt;</span>
                <span class="s">&lt;SystemLocale&gt;en-US&lt;/SystemLocale&gt;</span>
                <span class="s">&lt;UILanguage&gt;en-US&lt;/UILanguage&gt;</span>
                <span class="s">&lt;UILanguageFallback&gt;en-US&lt;/UILanguageFallback&gt;</span>
                <span class="s">&lt;UserLocale&gt;en-US&lt;/UserLocale&gt;</span>
            <span class="s">&lt;/component&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-Security-SPP-UX" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;SkipAutoActivation&gt;true&lt;/SkipAutoActivation&gt;</span>
            <span class="s">&lt;/component&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-SQMApi" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;CEIPEnabled&gt;0&lt;/CEIPEnabled&gt;</span>
            <span class="s">&lt;/component&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;ComputerName&gt;WindowsVM&lt;/ComputerName&gt;</span>
                <span class="s">&lt;ProductKey&gt;W269N-WFGWX-YVC9B-4J6C9-T83GX&lt;/ProductKey&gt;</span>
            <span class="s">&lt;/component&gt;</span>
        <span class="s">&lt;/settings&gt;</span>
        <span class="s">&lt;settings pass="oobeSystem"&gt;</span>
            <span class="s">&lt;component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span>
                <span class="s">&lt;AutoLogon&gt;</span>
                    <span class="s">&lt;Password&gt;</span>
                        <span class="s">&lt;Value&gt;changepassword&lt;/Value&gt;</span>
                        <span class="s">&lt;PlainText&gt;true&lt;/PlainText&gt;</span>
                    <span class="s">&lt;/Password&gt;</span>
                    <span class="s">&lt;Enabled&gt;true&lt;/Enabled&gt;</span>
                    <span class="s">&lt;Username&gt;Administrator&lt;/Username&gt;</span>
                <span class="s">&lt;/AutoLogon&gt;</span>
                <span class="s">&lt;OOBE&gt;</span>
                    <span class="s">&lt;HideEULAPage&gt;true&lt;/HideEULAPage&gt;</span>
                    <span class="s">&lt;HideOEMRegistrationScreen&gt;true&lt;/HideOEMRegistrationScreen&gt;</span>
                    <span class="s">&lt;HideOnlineAccountScreens&gt;true&lt;/HideOnlineAccountScreens&gt;</span>
                    <span class="s">&lt;HideWirelessSetupInOOBE&gt;true&lt;/HideWirelessSetupInOOBE&gt;</span>
                    <span class="s">&lt;NetworkLocation&gt;Home&lt;/NetworkLocation&gt;</span>
                    <span class="s">&lt;SkipUserOOBE&gt;true&lt;/SkipUserOOBE&gt;</span>
                    <span class="s">&lt;SkipMachineOOBE&gt;true&lt;/SkipMachineOOBE&gt;</span>
                    <span class="s">&lt;ProtectYourPC&gt;3&lt;/ProtectYourPC&gt;</span>
                <span class="s">&lt;/OOBE&gt;</span>
                <span class="s">&lt;UserAccounts&gt;</span>
                    <span class="s">&lt;LocalAccounts&gt;</span>
                        <span class="s">&lt;LocalAccount wcm:action="add"&gt;</span>
                            <span class="s">&lt;Password&gt;</span>
                                <span class="s">&lt;Value&gt;changepassword&lt;/Value&gt;</span>
                                <span class="s">&lt;PlainText&gt;true&lt;/PlainText&gt;</span>
                            <span class="s">&lt;/Password&gt;</span>
                            <span class="s">&lt;Description&gt;&lt;/Description&gt;</span>
                            <span class="s">&lt;DisplayName&gt;Administrator&lt;/DisplayName&gt;</span>
                            <span class="s">&lt;Group&gt;Administrators&lt;/Group&gt;</span>
                            <span class="s">&lt;Name&gt;Administrator&lt;/Name&gt;</span>
                        <span class="s">&lt;/LocalAccount&gt;</span>
                    <span class="s">&lt;/LocalAccounts&gt;</span>
                <span class="s">&lt;/UserAccounts&gt;</span>
                <span class="s">&lt;RegisteredOrganization&gt;&lt;/RegisteredOrganization&gt;</span>
                <span class="s">&lt;RegisteredOwner&gt;Administrator&lt;/RegisteredOwner&gt;</span>
                <span class="s">&lt;DisableAutoDaylightTimeSet&gt;false&lt;/DisableAutoDaylightTimeSet&gt;</span>
                <span class="s">&lt;FirstLogonCommands&gt;</span>
                    <span class="s">&lt;SynchronousCommand wcm:action="add"&gt;</span>
                        <span class="s">&lt;Description&gt;Control Panel View&lt;/Description&gt;</span>
                        <span class="s">&lt;Order&gt;1&lt;/Order&gt;</span>
                        <span class="s">&lt;CommandLine&gt;reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel" /v StartupPage /t REG_DWORD /d 1 /f&lt;/CommandLine&gt;</span>
                        <span class="s">&lt;RequiresUserInput&gt;true&lt;/RequiresUserInput&gt;</span>
                    <span class="s">&lt;/SynchronousCommand&gt;</span>
                    <span class="s">&lt;SynchronousCommand wcm:action="add"&gt;</span>
                        <span class="s">&lt;Order&gt;2&lt;/Order&gt;</span>
                        <span class="s">&lt;Description&gt;Control Panel Icon Size&lt;/Description&gt;</span>
                        <span class="s">&lt;RequiresUserInput&gt;false&lt;/RequiresUserInput&gt;</span>
                        <span class="s">&lt;CommandLine&gt;reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel" /v AllItemsIconView /t REG_DWORD /d 0 /f&lt;/CommandLine&gt;</span>
                    <span class="s">&lt;/SynchronousCommand&gt;</span>
                    <span class="s">&lt;SynchronousCommand wcm:action="add"&gt;</span>
                        <span class="s">&lt;Order&gt;3&lt;/Order&gt;</span>
                        <span class="s">&lt;RequiresUserInput&gt;false&lt;/RequiresUserInput&gt;</span>
                        <span class="s">&lt;CommandLine&gt;cmd /C wmic useraccount where name="Administrator" set PasswordExpires=false&lt;/CommandLine&gt;</span>
                        <span class="s">&lt;Description&gt;Password Never Expires&lt;/Description&gt;</span>
                    <span class="s">&lt;/SynchronousCommand&gt;</span>
                    <span class="s">&lt;SynchronousCommand wcm:action="add"&gt;</span>
                        <span class="s">&lt;Order&gt;4&lt;/Order&gt;</span>
                        <span class="s">&lt;Description&gt;Remove AutoAdminLogon&lt;/Description&gt;</span>
                        <span class="s">&lt;RequiresUserInput&gt;false&lt;/RequiresUserInput&gt;</span>
                        <span class="s">&lt;CommandLine&gt;reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoAdminLogon /t REG_SZ /d 0 /f&lt;/CommandLine&gt;</span>
                    <span class="s">&lt;/SynchronousCommand&gt;</span>
                    <span class="s">&lt;SynchronousCommand wcm:action="add"&gt;</span>
                        <span class="s">&lt;Order&gt;5&lt;/Order&gt;</span>
                        <span class="s">&lt;RequiresUserInput&gt;false&lt;/RequiresUserInput&gt;</span>
                        <span class="s">&lt;CommandLine&gt;cmd /c shutdown /s /f /t 10&lt;/CommandLine&gt;</span>
                        <span class="s">&lt;Description&gt;Shuts down the system&lt;/Description&gt;</span>
                    <span class="s">&lt;/SynchronousCommand&gt;</span>
                <span class="s">&lt;/FirstLogonCommands&gt;</span>
                <span class="s">&lt;TimeZone&gt;Alaskan Standard Time&lt;/TimeZone&gt;</span>
            <span class="s">&lt;/component&gt;</span>
        <span class="s">&lt;/settings&gt;</span>
    <span class="s">&lt;/unattend&gt;</span>
<span class="s">---</span>
</code></pre></div></div>

<h2 id="creating-the-pipeline">Creating the Pipeline</h2>

<p>Let’s create a pipeline which consists of the following tasks.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  create-source-dv <span class="nt">---</span> create-vm-from-manifest <span class="nt">---</span> wait-for-vmi-status <span class="nt">---</span> cleanup-vm
                    |
    create-base-dv <span class="nt">--</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">create-source-dv</code> task downloads a Windows source ISO into a PVC called <code class="language-plaintext highlighter-rouge">windows-10-source-*</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">create-base-dv</code> task creates an empty PVC for new windows installation called <code class="language-plaintext highlighter-rouge">windows-10-base-*</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">create-vm-from-manifest</code> task creates a VM called <code class="language-plaintext highlighter-rouge">windows-installer-*</code>
from the empty PVC and with the <code class="language-plaintext highlighter-rouge">windows-10-source-*</code> PVC attached as a CD-ROM.</li>
  <li><code class="language-plaintext highlighter-rouge">wait-for-vmi-status</code> task waits until the VM shuts down.</li>
  <li><code class="language-plaintext highlighter-rouge">cleanup-vm</code> deletes the installer VM and ISO PVC.</li>
  <li>The output artifact will be the <code class="language-plaintext highlighter-rouge">windows-10-base-*</code> PVC with the Windows installation.</li>
</ol>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">tekton.dev/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pipeline</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">windows-installer</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">params</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">winImageDownloadURL</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">string</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">autounattendConfigMapName</span>
      <span class="na">default</span><span class="pi">:</span> <span class="s">windows-10-autounattend</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">string</span>
  <span class="na">tasks</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">create-source-dv</span>
      <span class="na">params</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">manifest</span>
          <span class="na">value</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">apiVersion: cdi.kubevirt.io/v1beta1</span>
            <span class="s">kind: DataVolume</span>
            <span class="s">metadata:</span>
              <span class="s">generateName: windows-10-source-</span>
            <span class="s">spec:</span>
              <span class="s">pvc:</span>
                <span class="s">accessModes:</span>
                  <span class="s">- ReadWriteOnce</span>
                <span class="s">resources:</span>
                  <span class="s">requests:</span>
                    <span class="s">storage: 7Gi</span>
                <span class="s">volumeMode: Filesystem</span>
              <span class="s">source:</span>
                <span class="s">http:</span>
                  <span class="s">url: $(params.winImageDownloadURL)</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">waitForSuccess</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s1">'</span><span class="s">true'</span>
      <span class="na">timeout</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2h'</span>
      <span class="na">taskRef</span><span class="pi">:</span>
        <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterTask</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">create-datavolume-from-manifest</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">create-base-dv</span>
      <span class="na">params</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">manifest</span>
          <span class="na">value</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">apiVersion: cdi.kubevirt.io/v1beta1</span>
            <span class="s">kind: DataVolume</span>
            <span class="s">metadata:</span>
              <span class="s">generateName: windows-10-base-</span>
            <span class="s">spec:</span>
              <span class="s">pvc:</span>
                <span class="s">accessModes:</span>
                  <span class="s">- ReadWriteOnce</span>
                <span class="s">resources:</span>
                  <span class="s">requests:</span>
                    <span class="s">storage: 20Gi</span>
                <span class="s">volumeMode: Filesystem</span>
              <span class="s">source:</span>
                <span class="s">blank: {}</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">waitForSuccess</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s1">'</span><span class="s">true'</span>
      <span class="na">taskRef</span><span class="pi">:</span>
        <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterTask</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">create-datavolume-from-manifest</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">create-vm-from-manifest</span>
      <span class="na">params</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">manifest</span>
          <span class="na">value</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">apiVersion: kubevirt.io/v1alpha3</span>
            <span class="s">kind: VirtualMachine</span>
            <span class="s">metadata:</span>
              <span class="s">generateName: windows-installer-</span>
              <span class="s">annotation:</span>
                <span class="s">description: Windows VM generated by windows-installer pipeline</span>
              <span class="s">labels:</span>
                <span class="s">app: windows-installer</span>
            <span class="s">spec:</span>
              <span class="s">runStrategy: RerunOnFailure</span>
              <span class="s">template:</span>
                <span class="s">metadata:</span>
                  <span class="s">labels:</span>
                    <span class="s">kubevirt.io/domain: windows-installer</span>
                <span class="s">spec:</span>
                  <span class="s">domain:</span>
                    <span class="s">cpu:</span>
                      <span class="s">sockets: 2</span>
                      <span class="s">cores: 1</span>
                      <span class="s">threads: 1</span>
                    <span class="s">resources:</span>
                      <span class="s">requests:</span>
                        <span class="s">memory: 2Gi</span>
                    <span class="s">devices:</span>
                      <span class="s">disks:</span>
                        <span class="s">- name: installcdrom</span>
                          <span class="s">cdrom:</span>
                            <span class="s">bus: sata</span>
                          <span class="s">bootOrder: 1</span>
                        <span class="s">- name: rootdisk</span>
                          <span class="s">bootOrder: 2</span>
                          <span class="s">disk:</span>
                            <span class="s">bus: virtio</span>
                        <span class="s">- name: virtiocontainerdisk</span>
                          <span class="s">cdrom:</span>
                            <span class="s">bus: sata</span>
                        <span class="s">- name: sysprepconfig</span>
                          <span class="s">cdrom:</span>
                            <span class="s">bus: sata</span>
                      <span class="s">interfaces:</span>
                        <span class="s">- bridge: {}</span>
                          <span class="s">name: default</span>
                      <span class="s">inputs:</span>
                        <span class="s">- type: tablet</span>
                          <span class="s">bus: usb</span>
                          <span class="s">name: tablet</span>
                  <span class="s">networks:</span>
                    <span class="s">- name: default</span>
                      <span class="s">pod: {}</span>
                  <span class="s">volumes:</span>
                    <span class="s">- name: installcdrom</span>
                    <span class="s">- name: rootdisk</span>
                    <span class="s">- name: virtiocontainerdisk</span>
                      <span class="s">containerDisk:</span>
                        <span class="s">image: kubevirt/virtio-container-disk</span>
                    <span class="s">- name: sysprepconfig</span>
                      <span class="s">sysprep:</span>
                        <span class="s">configMap:</span>
                          <span class="s">name: $(params.autounattendConfigMapName)</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">ownDataVolumes</span>
          <span class="na">value</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s2">"</span><span class="s">installcdrom:$(tasks.create-source-dv.results.name)"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">dataVolumes</span>
          <span class="na">value</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s2">"</span><span class="s">rootdisk:$(tasks.create-base-dv.results.name)"</span>
      <span class="na">runAfter</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">create-source-dv</span>
        <span class="pi">-</span> <span class="s">create-base-dv</span>
      <span class="na">taskRef</span><span class="pi">:</span>
        <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterTask</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">create-vm-from-manifest</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">wait-for-vmi-status</span>
      <span class="na">params</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">vmiName</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">$(tasks.create-vm-from-manifest.results.name)"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">successCondition</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">status.phase</span><span class="nv"> </span><span class="s">==</span><span class="nv"> </span><span class="s">Succeeded"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">failureCondition</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">status.phase</span><span class="nv"> </span><span class="s">in</span><span class="nv"> </span><span class="s">(Failed,</span><span class="nv"> </span><span class="s">Unknown)"</span>
      <span class="na">runAfter</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">create-vm-from-manifest</span>
      <span class="na">timeout</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2h'</span>
      <span class="na">taskRef</span><span class="pi">:</span>
        <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterTask</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">wait-for-vmi-status</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">cleanup-vm</span>
      <span class="na">params</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">vmName</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">$(tasks.create-vm-from-manifest.results.name)"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">delete</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
      <span class="na">runAfter</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">wait-for-vmi-status</span>
      <span class="na">taskRef</span><span class="pi">:</span>
        <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterTask</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">cleanup-vm</span>
</code></pre></div></div>

<h2 id="running-the-pipeline">Running the Pipeline</h2>

<p>To run the pipeline we need to create the following <code class="language-plaintext highlighter-rouge">PipelineRun</code> which references our <code class="language-plaintext highlighter-rouge">Pipeline</code>.
Before we do that, we should replace DOWNLOAD_URL with the Windows source URL we obtained earlier.</p>

<p>The <code class="language-plaintext highlighter-rouge">PipelineRun</code> also specifies the serviceAccount names for all the steps/tasks and the timeout for the whole <code class="language-plaintext highlighter-rouge">Pipeline</code>.
The timeout should be changed appropriately; for example if you have a slow download connection.
You can also set a timeout for each task in the <code class="language-plaintext highlighter-rouge">Pipeline</code> definition.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">tekton.dev/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PipelineRun</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">generateName</span><span class="pi">:</span> <span class="s">windows-installer-run-</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">params</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">winImageDownloadURL</span>
      <span class="na">value</span><span class="pi">:</span> <span class="s">DOWNLOAD_URL</span>
  <span class="na">pipelineRef</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">windows-installer</span>
  <span class="na">timeout</span><span class="pi">:</span> <span class="s1">'</span><span class="s">5h'</span>
  <span class="na">serviceAccountNames</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">taskName</span><span class="pi">:</span> <span class="s">create-source-dv</span>
      <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">create-datavolume-from-manifest-task</span>
    <span class="pi">-</span> <span class="na">taskName</span><span class="pi">:</span> <span class="s">create-base-dv</span>
      <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">create-datavolume-from-manifest-task</span>
    <span class="pi">-</span> <span class="na">taskName</span><span class="pi">:</span> <span class="s">create-vm-from-manifest</span>
      <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">create-vm-from-manifest-task</span>
    <span class="pi">-</span> <span class="na">taskName</span><span class="pi">:</span> <span class="s">wait-for-vmi-status</span>
      <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">wait-for-vmi-status-task</span>
    <span class="pi">-</span> <span class="na">taskName</span><span class="pi">:</span> <span class="s">cleanup-vm</span>
      <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">cleanup-vm-task</span>
</code></pre></div></div>

<h2 id="inspecting-the-output">Inspecting the output</h2>

<p>Firstly, you can inspect the progress of the windows-10-source and windows-10-base import:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get dvs | <span class="nb">grep </span>windows-10-

<span class="o">&gt;</span> windows-10-base-8zxwr     Succeeded          100.0%                21s
<span class="o">&gt;</span> windows-10-source-jdv64   ImportInProgress   1.01%                 20s
</code></pre></div></div>

<p>To inspect the status of the pipeline run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pipelinerun <span class="nt">-l</span> <span class="s2">"tekton.dev/pipeline=windows-installer"</span>

<span class="o">&gt;</span> NAME                          SUCCEEDED   REASON                          STARTTIME   COMPLETIONTIME
<span class="o">&gt;</span> windows-installer-run-n2mjf   Unknown     Running                         118s
</code></pre></div></div>

<p>To check the status of each task and its pods:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pipelinerun <span class="nt">-o</span> yaml <span class="nt">-l</span> <span class="s2">"tekton.dev/pipeline=windows-installer"</span>
kubectl get pods <span class="nt">-l</span> <span class="s2">"tekton.dev/pipeline=windows-installer"</span>
</code></pre></div></div>

<p>Once the pipeline run completes, you should be left with a <code class="language-plaintext highlighter-rouge">windows-10-base-xxxxx</code> PVC (backed by a DataVolume).
You can then create a new VM with a copy of this PVC to test it.
You need to replace PVC_NAME with <code class="language-plaintext highlighter-rouge">windows-10-base-xxxxx</code> (you can use <code class="language-plaintext highlighter-rouge">kubectl get dvs -o name | grep -o "windows-10-base-.*"</code>) and PVC_NAMESPACE with the correct namespace in the following YAML.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubevirt.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualMachine</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">windows-10-vm</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">dataVolumeTemplates</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">cdi.kubevirt.io/v1beta1</span>
      <span class="na">kind</span><span class="pi">:</span> <span class="s">DataVolume</span>
      <span class="na">metadata</span><span class="pi">:</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">windows-10-vm-root</span>
      <span class="na">spec</span><span class="pi">:</span>
        <span class="na">pvc</span><span class="pi">:</span>
          <span class="na">accessModes</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">ReadWriteMany</span>
          <span class="na">resources</span><span class="pi">:</span>
            <span class="na">requests</span><span class="pi">:</span>
              <span class="na">storage</span><span class="pi">:</span> <span class="s">20Gi</span>
        <span class="na">source</span><span class="pi">:</span>
          <span class="na">pvc</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">PVC_NAME</span>
            <span class="na">namespace</span><span class="pi">:</span> <span class="s">PVC_NAMESPACE</span>
  <span class="na">running</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">kubevirt.io/domain</span><span class="pi">:</span> <span class="s">windows-10-vm</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">domain</span><span class="pi">:</span>
        <span class="na">cpu</span><span class="pi">:</span>
          <span class="na">sockets</span><span class="pi">:</span> <span class="m">2</span>
          <span class="na">cores</span><span class="pi">:</span> <span class="m">1</span>
          <span class="na">threads</span><span class="pi">:</span> <span class="m">1</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">2Gi</span>
        <span class="na">devices</span><span class="pi">:</span>
          <span class="na">disks</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">rootdisk</span>
              <span class="na">bootOrder</span><span class="pi">:</span> <span class="m">1</span>
              <span class="na">disk</span><span class="pi">:</span>
                <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">virtiocontainerdisk</span>
              <span class="na">cdrom</span><span class="pi">:</span>
                <span class="na">bus</span><span class="pi">:</span> <span class="s">sata</span>
          <span class="na">interfaces</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">bridge</span><span class="pi">:</span> <span class="pi">{}</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
          <span class="na">inputs</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">tablet</span>
              <span class="na">bus</span><span class="pi">:</span> <span class="s">usb</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">tablet</span>
      <span class="na">networks</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">default</span>
          <span class="na">pod</span><span class="pi">:</span> <span class="pi">{}</span>
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">rootdisk</span>
          <span class="na">dataVolume</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">windows-10-vm-root</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">virtiocontainerdisk</span>
          <span class="na">containerDisk</span><span class="pi">:</span>
            <span class="na">image</span><span class="pi">:</span> <span class="s">kubevirt/virtio-container-disk</span>
</code></pre></div></div>

<p>You can start the VM and login with <code class="language-plaintext highlighter-rouge">Administrator</code> : <code class="language-plaintext highlighter-rouge">changepassword</code> credentials. Then you should be welcomed by your fresh VM.</p>

<div class="zoom">
  <img src="/assets/2021-04-21-Automated-Windows-Installation-With-Tekton-Pipelines/win-started.png" width="100" height="75" itemprop="thumbnail" alt="Started Windows VM" />
</div>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://github.com/kubevirt/kubevirt-tekton-tasks/tree/main/examples/pipelines/windows-installer">YAML files used in this example</a></li>
  <li><a href="https://github.com/kubevirt/kubevirt-tekton-tasks">KubeVirt Tekton Tasks</a></li>
  <li><a href="https://github.com/tektoncd/pipeline">Tekton Pipelines</a></li>
</ul>]]></content><author><name>Filip Křepinský</name></author><category term="news" /><category term="kubevirt" /><category term="Kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="Tekton Pipelines" /><category term="KubeVirt Tekton Tasks" /><category term="Windows" /><summary type="html"><![CDATA[This blog shows how KubeVirt Tekton Tasks can be utilized to automatically install and setup Windows VMs from scratch]]></summary></entry><entry><title type="html">The KubeVirt Summit 2021 is a wrap!</title><link href="https://kubevirt.io//2021/KubeVirt-Summit-Wrap-Up.html" rel="alternate" type="text/html" title="The KubeVirt Summit 2021 is a wrap!" /><published>2021-03-03T00:00:00+00:00</published><updated>2021-03-03T00:00:00+00:00</updated><id>https://kubevirt.io//2021/KubeVirt-Summit-Wrap-Up</id><content type="html" xml:base="https://kubevirt.io//2021/KubeVirt-Summit-Wrap-Up.html"><![CDATA[<p>Just a few weeks ago, the KubeVirt community had their first ever dedicated
online event, the <a href="/summit/">KubeVirt Summit</a>!</p>

<p>We are very happy to have had this opportunity to meet so many community
members, hear from users, vendors and contributors, and learn so many things
about KubeVirt.</p>

<p>If you missed the event, or if you were there and want to remember the great
time we had, the <a href="https://youtube.com/playlist?list=PLnLpXX8KHIYyQi7Phsf5-73r5fj1AOBox">session recordings</a>
are available in the <a href="https://www.youtube.com/c/KubeVirt">KubeVirt YouTube channel</a>.</p>

<p>The landing page about the <a href="/summit/">KubeVirt Summit</a>
contains a detailed list of all the sessions, with information about the
contents, presenters, and direct links to each session recording and slides
(where available).</p>

<h2 id="thanks">Thanks</h2>

<p>We would like to thank everyone who contributed to make this event happen: all
the presenters / session leads, everyone who proposed a session, the various
community members who contributed to the organization, all the attendees, and
the <a href="https://cncf.io/">Container-native Computing Foundation</a> who sponsored the
event.</p>

<h2 id="i-want-more">I want more</h2>

<p>We are just wrapping up this first edition. Based on this experience, we really
hope to have more community events of this type in the future, but it is still a
bit early to say when/where how.</p>

<p>For now, please keep the conversations going through the various community channels:</p>

<ul>
  <li>The <a href="https://groups.google.com/forum/#!forum/kubevirt-dev">mailing list</a></li>
  <li>The <a href="https://kubernetes.slack.com/archives/C8ED7RKFE">#virtualization Slack channel</a> in <a href="https://slack.k8s.io/">Kubernetes Slack</a></li>
  <li>Our <a href="https://calendar.google.com/calendar/embed?src=18pc0jur01k8f2cccvn5j04j1g%40group.calendar.google.com&amp;ctz=Etc%2FGMT">community meetings</a></li>
  <li>The <a href="https://github.com/kubevirt">github repositories</a></li>
  <li>Twitter: <a href="https://twitter.com/kubevirt">@kubevirt</a></li>
</ul>]]></content><author><name>Pep Turró Mauri</name></author><category term="news" /><category term="kubevirt" /><category term="event" /><category term="community" /><summary type="html"><![CDATA[The KubeVirt community held their first dedicated online event last month.]]></summary></entry></feed>